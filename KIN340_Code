#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2021.1.4),
    on November 15, 2022, at 19:20
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

from __future__ import absolute_import, division

from psychopy import locale_setup
from psychopy import prefs
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

from psychopy.hardware import keyboard



# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

# Store info about the experiment session
psychopyVersion = '2021.1.4'
expName = 'KIN340_Cognitive'  # from the Builder filename that created this script
expInfo = {'netid': ''}
dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
expInfo['psychopyVersion'] = psychopyVersion

# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + u'data/%s_%s_%s' % (expInfo['netid'], expName, expInfo['date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
    extraInfo=expInfo, runtimeInfo=None,
    originPath='C:\\Users\\jadam\\Box\\ExPPL\\Cognitive Tests\\KIN340_CognitiveTest\\KIN340_Cognitive_lastrun.py',
    savePickle=True, saveWideText=True,
    dataFileName=filename)
# save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.EXP)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

endExpNow = False  # flag for 'escape' or other condition => quit the exp
frameTolerance = 0.001  # how close to onset before 'same' frame

# Start Code - component code to be run after the window creation

# Setup the Window
win = visual.Window(
    size=[1920, 1200], fullscr=True, screen=0, 
    winType='pyglet', allowGUI=False, allowStencil=False,
    monitor='testMonitor', color=[1,1,1], colorSpace='rgb',
    blendMode='avg', useFBO=True, 
    units='height')
# store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None:
    frameDur = 1.0 / round(expInfo['frameRate'])
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess

# create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard()

# Initialize components for Routine "IntroToTasks"
IntroToTasksClock = core.Clock()
text_7 = visual.TextStim(win=win, name='text_7',
    text='Cognitive Testing Day\n\nToday you will be completing three different cognitive tasks:\n\n1) Implicit Attitudes Task - 10 minutes\n2) Cognitive Control Task - 5 minutes\n3) Working Memory/Updating Task - 10 minutes\n\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_17 = keyboard.Keyboard()

# Initialize components for Routine "WelcomeScreen"
WelcomeScreenClock = core.Clock()
text = visual.TextStim(win=win, name='text',
    text="Implicit attitudes test\n\nThere will be 4 different types of the implicit attitudes task. Each with a practice trial followed by the test trial\n\nYou will be presented with words to classify into categories using either the 'z' or 'm' key. \n\nPlace your left index finger on the 'z' key\nPlace your right index finger on the 'm' key\n\nPlease respond as quickly and accurately as possible.\n\nPress SPACEBAR to continue.",
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
keyWelcome = keyboard.Keyboard()

# Initialize components for Routine "Instructions1_P"
Instructions1_PClock = core.Clock()
textInstructions = visual.TextStim(win=win, name='textInstructions',
    text='You will now do a Practice Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive = joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
textbox = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Negative category \nPress the 'm' key if the word belongs in the Exercise & Positive category ", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox',
     autoLog=True,
)
key_resp = keyboard.Keyboard()

# Initialize components for Routine "FS"
FSClock = core.Clock()
fs1 = visual.TextStim(win=win, name='fs1',
    text='Please fill out the Feeling Scale:\n\nPre-Stroop Test 1\n\nRemember to answer how you feel RIGHT NOW',
    font='Open Sans',
    pos=(0, 0), height=0.04, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_31 = keyboard.Keyboard()

# Initialize components for Routine "trial1p"
trial1pClock = core.Clock()
Ex_Good = visual.TextStim(win=win, name='Ex_Good',
    text='"M" = EXERCISE & POSITIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
Bad = visual.TextStim(win=win, name='Bad',
    text='"Z" = NEGATIVE',
    font='Open Sans',
    pos=(-.7, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
textStudyWork = visual.TextStim(win=win, name='textStudyWork',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_2 = keyboard.Keyboard()
myCount = 0

# Initialize components for Routine "feedback1"
feedback1Clock = core.Clock()
text_13 = visual.TextStim(win=win, name='text_13',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "Instructions1_T"
Instructions1_TClock = core.Clock()
TextInstructions = visual.TextStim(win=win, name='TextInstructions',
    text='You will now do the Test Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive = joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin\n',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
textbox2 = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Negative category \nPress the 'm' key if the word belongs in the Exercise & Positive category ", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox2',
     autoLog=True,
)
key_resp_3 = keyboard.Keyboard()

# Initialize components for Routine "trial1t"
trial1tClock = core.Clock()
ExGood = visual.TextStim(win=win, name='ExGood',
    text='"M" = EXERCISE & POSITIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
txt_bad = visual.TextStim(win=win, name='txt_bad',
    text='"Z" = NEGATIVE',
    font='Open Sans',
    pos=(-.7, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
txt_study = visual.TextStim(win=win, name='txt_study',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_13 = keyboard.Keyboard()
myCount1 = 0


# Initialize components for Routine "Instructions2_P"
Instructions2_PClock = core.Clock()
text_Instr = visual.TextStim(win=win, name='text_Instr',
    text='You will now do a Practice Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive =  joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
textbox3 = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Positive category\nPress the 'm' key if the word belongs in the Exercise & Negative category", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox3',
     autoLog=True,
)
key_resp_4 = keyboard.Keyboard()

# Initialize components for Routine "trial2p"
trial2pClock = core.Clock()
Ex_Bad = visual.TextStim(win=win, name='Ex_Bad',
    text='"M" = EXERCISE & NEGATIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
Good = visual.TextStim(win=win, name='Good',
    text='"Z" = POSITIVE',
    font='Open Sans',
    pos=(-.7, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
SCIAT = visual.TextStim(win=win, name='SCIAT',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_5 = keyboard.Keyboard()
myCount2 = 0


# Initialize components for Routine "feedback2"
feedback2Clock = core.Clock()
text_14 = visual.TextStim(win=win, name='text_14',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "Instructions2_T"
Instructions2_TClock = core.Clock()
instr = visual.TextStim(win=win, name='instr',
    text='You will now begin the Test Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive =  joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin\n',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
textbox3_2 = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Positive category\nPress the 'm' key if the word belongs in the Exercise & Negative category", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox3_2',
     autoLog=True,
)
key_resp_6 = keyboard.Keyboard()

# Initialize components for Routine "trial2t"
trial2tClock = core.Clock()
Txt_ExBad = visual.TextStim(win=win, name='Txt_ExBad',
    text='"M" = EXERCISE & NEGATIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
txt_good = visual.TextStim(win=win, name='txt_good',
    text='"Z" = POSITIVE',
    font='Open Sans',
    pos=(-.7, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
txt_Studywords = visual.TextStim(win=win, name='txt_Studywords',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_14 = keyboard.Keyboard()
myCount3 = 0

# Initialize components for Routine "Instructions3_P"
Instructions3_PClock = core.Clock()
text_3 = visual.TextStim(win=win, name='text_3',
    text='You will now do a Practice Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive = joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
textbox4 = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Exercise & Positive category\nPress the 'm' key if the word belongs in the Negative category", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox4',
     autoLog=True,
)
key_resp_7 = keyboard.Keyboard()

# Initialize components for Routine "Trial3p"
Trial3pClock = core.Clock()
text_bad = visual.TextStim(win=win, name='text_bad',
    text='"M" = NEGATIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
text_ExGood = visual.TextStim(win=win, name='text_ExGood',
    text='"Z" = EXERCISE & POSITIVE',
    font='Open Sans',
    pos=(-.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_SCIAT = visual.TextStim(win=win, name='text_SCIAT',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_11 = keyboard.Keyboard()
myCount4 = 0

# Initialize components for Routine "feedback3"
feedback3Clock = core.Clock()
text_15 = visual.TextStim(win=win, name='text_15',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "Instructions3_T"
Instructions3_TClock = core.Clock()
text_4 = visual.TextStim(win=win, name='text_4',
    text='You will now do the Test Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive = joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin\n',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
textbox4_2 = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Exercise & Positive category\nPress the 'm' key if the word belongs in the Negative category", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox4_2',
     autoLog=True,
)
key_resp_8 = keyboard.Keyboard()

# Initialize components for Routine "trial3t"
trial3tClock = core.Clock()
textbad = visual.TextStim(win=win, name='textbad',
    text='"M" = NEGATIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
txt_ExGood = visual.TextStim(win=win, name='txt_ExGood',
    text='"Z" = EXERCISE & POSITIVE',
    font='Open Sans',
    pos=(-.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
txt_SCIAT = visual.TextStim(win=win, name='txt_SCIAT',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_15 = keyboard.Keyboard()
myCount5 = 0

# Initialize components for Routine "Instructions4_P"
Instructions4_PClock = core.Clock()
text_5 = visual.TextStim(win=win, name='text_5',
    text='You will now do a Practice Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive = joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
textbox5 = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Exercise & Negative category\nPress the 'm' key if the word belongs in the Positive category", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox5',
     autoLog=True,
)
key_resp_9 = keyboard.Keyboard()

# Initialize components for Routine "Trial4p"
Trial4pClock = core.Clock()
good = visual.TextStim(win=win, name='good',
    text='"M" = POSITIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
ExNeg = visual.TextStim(win=win, name='ExNeg',
    text='"Z" = EXERCISE & NEGATIVE',
    font='Open Sans',
    pos=(-.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
text_SC_IAT = visual.TextStim(win=win, name='text_SC_IAT',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_12 = keyboard.Keyboard()
myCount6 = 0


# Initialize components for Routine "feedback4"
feedback4Clock = core.Clock()
text_16 = visual.TextStim(win=win, name='text_16',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "Instructions4_T"
Instructions4_TClock = core.Clock()
text_6 = visual.TextStim(win=win, name='text_6',
    text='You will now do the Test Trial\n\n\n\n\n\nExamples of categories include:\n\nExercise = weightlifting, conditioning\nPositive = joy, fun\nNegative = horrible, dreary\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to begin',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
textbox5_2 = visual.TextBox2(
     win, text="Press the 'z' key if the word belongs in the Exercise & Negative category\nPress the 'm' key if the word belongs in the Positive category", font='Open Sans',
     pos=(0.3, .15),     letterHeight=0.03,
     size=(1.4, 0), borderWidth=0.0,
     color='black', colorSpace='rgb',
     opacity=None,
     bold=True, italic=False,
     lineSpacing=1.3,
     padding=None,
     anchor='center',
     fillColor='white', borderColor='white',
     flipHoriz=False, flipVert=False,
     editable=False,
     name='textbox5_2',
     autoLog=True,
)
key_resp_10 = keyboard.Keyboard()

# Initialize components for Routine "trial4t"
trial4tClock = core.Clock()
txt_good1 = visual.TextStim(win=win, name='txt_good1',
    text='"M" = POSITIVE',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
txt_ExNeg = visual.TextStim(win=win, name='txt_ExNeg',
    text='"Z" = EXERCISE & NEGATIVE',
    font='Open Sans',
    pos=(-.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
SC_IAT = visual.TextStim(win=win, name='SC_IAT',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-2.0);
key_resp_16 = keyboard.Keyboard()
myCount7 = 0

# Initialize components for Routine "STROOP"
STROOPClock = core.Clock()
text_8 = visual.TextStim(win=win, name='text_8',
    text='You have completed the implicit attitudes test\n\nYou will now begin the cognitive control task\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_18 = keyboard.Keyboard()

# Initialize components for Routine "Stroop_Instr"
Stroop_InstrClock = core.Clock()
text_9 = visual.TextStim(win=win, name='text_9',
    text='Cognitive Control Task - Practice Trial\n\nFor this task, words will appear on the screen in different colors red, blue or green.\n\nRespond to the COLOR of the word and not the word itself, as quickly and accurately as possible, using the appropriate keys:\n\nb = red\nn = blue\nm = green\n\nUse one hand.\n\nPress the SPACEBAR to start to begin ',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_19 = keyboard.Keyboard()

# Initialize components for Routine "pract_stroop"
pract_stroopClock = core.Clock()
b = visual.TextStim(win=win, name='b',
    text='"b" = Red',
    font='Open Sans',
    pos=(-.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
n = visual.TextStim(win=win, name='n',
    text='"n" = Blue',
    font='Open Sans',
    pos=(0, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
m = visual.TextStim(win=win, name='m',
    text='"m" = Green',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-2.0);
text_10 = visual.TextStim(win=win, name='text_10',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-3.0);
key_resp_20 = keyboard.Keyboard()

# Initialize components for Routine "feedbackS"
feedbackSClock = core.Clock()
text_17 = visual.TextStim(win=win, name='text_17',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "Stroop_Test"
Stroop_TestClock = core.Clock()
text_11 = visual.TextStim(win=win, name='text_11',
    text='You will now begin the Test Trial\n\nRespond to the COLOR of the word and not the word itself, as quickly and accurately as possible, using the appropriate keys:\n\nb = red\nn = blue\nm = green\n\nUse one hand.\n\nPress SPACEBAR to begin',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_21 = keyboard.Keyboard()

# Initialize components for Routine "trial_stroop"
trial_stroopClock = core.Clock()
b1 = visual.TextStim(win=win, name='b1',
    text='"b" = Red',
    font='Open Sans',
    pos=(-.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
n1 = visual.TextStim(win=win, name='n1',
    text='"n" = Blue',
    font='Open Sans',
    pos=(0, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-1.0);
m1 = visual.TextStim(win=win, name='m1',
    text='"m" = Green',
    font='Open Sans',
    pos=(.65, .4), height=0.02, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-2.0);
text_12 = visual.TextStim(win=win, name='text_12',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=-3.0);
key_resp_22 = keyboard.Keyboard()

# Initialize components for Routine "N_Back"
N_BackClock = core.Clock()
text_20 = visual.TextStim(win=win, name='text_20',
    text='You have completed the cognitive control task\n\nYou will now begin the working memory / updating tasks\n\nThere will be a practice trial followed by a test trial\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_26 = keyboard.Keyboard()

# Initialize components for Routine "Instructions_Nback1Pract"
Instructions_Nback1PractClock = core.Clock()
text_22 = visual.TextStim(win=win, name='text_22',
    text='You will now perform the Practice Trial for the n-1 test\n\nYou will be presented a sequence of letters one-by-one. For each letter presented, decide if the current letter is the same as the previous one. For example, in the following sequence of three letters, "C" ... "B" ... "B" ... the third trial ("B") is the same as the trial presented immediately before ("B"), thus you would press the SPACEBAR. In the example, "C" ... "B" ... "C", the third trial ("C") is different from the trial presented immediately before ("B" ), thus you would do nothing until the next trial is presented.\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_27 = keyboard.Keyboard()

# Initialize components for Routine "pract_nback"
pract_nbackClock = core.Clock()
pract_nbackstim = visual.TextStim(win=win, name='pract_nbackstim',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_nbackP1 = keyboard.Keyboard()

# Initialize components for Routine "feedback_Pnback1"
feedback_Pnback1Clock = core.Clock()
text_21 = visual.TextStim(win=win, name='text_21',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "Instructions_Nback1T"
Instructions_Nback1TClock = core.Clock()
text_23 = visual.TextStim(win=win, name='text_23',
    text='You will now begin the Test Trial\n\nRemember, press SPACEBAR only if the letter presented is the same as the previous one ( "B" ... "B") otherwise, do nothing ("B" ... "C"). \n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_28 = keyboard.Keyboard()

# Initialize components for Routine "nback1_trial"
nback1_trialClock = core.Clock()
nback1_stim = visual.TextStim(win=win, name='nback1_stim',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_29 = keyboard.Keyboard()

# Initialize components for Routine "Instructions_Nback2Pract"
Instructions_Nback2PractClock = core.Clock()
text_24 = visual.TextStim(win=win, name='text_24',
    text='You have just completed the n-1 test\n\nYou will now perform the Practice Trial for the n-2 test\n\nNow, instead of remembering only the previous letter you will have to remember the two previous letters\n\nYou will be presented a sequence of letters one-by-one. For each letter presented, decide if the current letter is the same as the one presented 2 trials ago." For example, in the following sequence of three letters, "B" ... "C" ... "B" ... the third trial ("B") is the same as the trial presented 2 letters ago ("B"), thus you would press the SPACEBAR. In the example, "B" ... "C" ... "C", the third trial ("C") is different from the trial presented 2 letters ago ("B" ), thus you would do nothing until the next trial is presented.\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_30 = keyboard.Keyboard()

# Initialize components for Routine "pract_nback2"
pract_nback2Clock = core.Clock()
pract_nback2stim = visual.TextStim(win=win, name='pract_nback2stim',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_nbackP2 = keyboard.Keyboard()

# Initialize components for Routine "Feedback_Pnback2"
Feedback_Pnback2Clock = core.Clock()
text_25 = visual.TextStim(win=win, name='text_25',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "Instructions_Nback"
Instructions_NbackClock = core.Clock()
text_18 = visual.TextStim(win=win, name='text_18',
    text='You will now begin the Test Trial\n\nRemember, press SPACEBAR only if the letter presented is the same as the one presented 2 letters ago ("B" ... "C" ... "B") otherwise, do nothing ( "B" ... "C" ... "C"). \n\nPress SPACEBAR to continue\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_23 = keyboard.Keyboard()

# Initialize components for Routine "nback2"
nback2Clock = core.Clock()
stim = visual.TextStim(win=win, name='stim',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_25 = keyboard.Keyboard()

# Initialize components for Routine "GoodbyeScreen"
GoodbyeScreenClock = core.Clock()
text_2 = visual.TextStim(win=win, name='text_2',
    text='Thanks for participating',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='black', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 

# ------Prepare to start Routine "IntroToTasks"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_17.keys = []
key_resp_17.rt = []
_key_resp_17_allKeys = []
# keep track of which components have finished
IntroToTasksComponents = [text_7, key_resp_17]
for thisComponent in IntroToTasksComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
IntroToTasksClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "IntroToTasks"-------
while continueRoutine:
    # get current time
    t = IntroToTasksClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=IntroToTasksClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_7* updates
    if text_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_7.frameNStart = frameN  # exact frame index
        text_7.tStart = t  # local t and not account for scr refresh
        text_7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_7, 'tStartRefresh')  # time at next scr refresh
        text_7.setAutoDraw(True)
    
    # *key_resp_17* updates
    waitOnFlip = False
    if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_17.frameNStart = frameN  # exact frame index
        key_resp_17.tStart = t  # local t and not account for scr refresh
        key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
        key_resp_17.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_17.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_17.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_17_allKeys.extend(theseKeys)
        if len(_key_resp_17_allKeys):
            key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
            key_resp_17.rt = _key_resp_17_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in IntroToTasksComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "IntroToTasks"-------
for thisComponent in IntroToTasksComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_7.started', text_7.tStartRefresh)
thisExp.addData('text_7.stopped', text_7.tStopRefresh)
# check responses
if key_resp_17.keys in ['', [], None]:  # No response was made
    key_resp_17.keys = None
thisExp.addData('key_resp_17.keys',key_resp_17.keys)
if key_resp_17.keys != None:  # we had a response
    thisExp.addData('key_resp_17.rt', key_resp_17.rt)
thisExp.addData('key_resp_17.started', key_resp_17.tStartRefresh)
thisExp.addData('key_resp_17.stopped', key_resp_17.tStopRefresh)
thisExp.nextEntry()
# the Routine "IntroToTasks" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "WelcomeScreen"-------
continueRoutine = True
# update component parameters for each repeat
keyWelcome.keys = []
keyWelcome.rt = []
_keyWelcome_allKeys = []
# keep track of which components have finished
WelcomeScreenComponents = [text, keyWelcome]
for thisComponent in WelcomeScreenComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
WelcomeScreenClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "WelcomeScreen"-------
while continueRoutine:
    # get current time
    t = WelcomeScreenClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=WelcomeScreenClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text* updates
    if text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text.frameNStart = frameN  # exact frame index
        text.tStart = t  # local t and not account for scr refresh
        text.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
        text.setAutoDraw(True)
    
    # *keyWelcome* updates
    waitOnFlip = False
    if keyWelcome.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        keyWelcome.frameNStart = frameN  # exact frame index
        keyWelcome.tStart = t  # local t and not account for scr refresh
        keyWelcome.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(keyWelcome, 'tStartRefresh')  # time at next scr refresh
        keyWelcome.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(keyWelcome.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(keyWelcome.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if keyWelcome.status == STARTED and not waitOnFlip:
        theseKeys = keyWelcome.getKeys(keyList=['space'], waitRelease=False)
        _keyWelcome_allKeys.extend(theseKeys)
        if len(_keyWelcome_allKeys):
            keyWelcome.keys = _keyWelcome_allKeys[-1].name  # just the last key pressed
            keyWelcome.rt = _keyWelcome_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in WelcomeScreenComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "WelcomeScreen"-------
for thisComponent in WelcomeScreenComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text.started', text.tStartRefresh)
thisExp.addData('text.stopped', text.tStopRefresh)
# check responses
if keyWelcome.keys in ['', [], None]:  # No response was made
    keyWelcome.keys = None
thisExp.addData('keyWelcome.keys',keyWelcome.keys)
if keyWelcome.keys != None:  # we had a response
    thisExp.addData('keyWelcome.rt', keyWelcome.rt)
thisExp.addData('keyWelcome.started', keyWelcome.tStartRefresh)
thisExp.addData('keyWelcome.stopped', keyWelcome.tStopRefresh)
thisExp.nextEntry()
# the Routine "WelcomeScreen" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Instructions1_P"-------
continueRoutine = True
# update component parameters for each repeat
key_resp.keys = []
key_resp.rt = []
_key_resp_allKeys = []
# keep track of which components have finished
Instructions1_PComponents = [textInstructions, textbox, key_resp]
for thisComponent in Instructions1_PComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions1_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions1_P"-------
while continueRoutine:
    # get current time
    t = Instructions1_PClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions1_PClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *textInstructions* updates
    if textInstructions.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textInstructions.frameNStart = frameN  # exact frame index
        textInstructions.tStart = t  # local t and not account for scr refresh
        textInstructions.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textInstructions, 'tStartRefresh')  # time at next scr refresh
        textInstructions.setAutoDraw(True)
    
    # *textbox* updates
    if textbox.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox.frameNStart = frameN  # exact frame index
        textbox.tStart = t  # local t and not account for scr refresh
        textbox.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox, 'tStartRefresh')  # time at next scr refresh
        textbox.setAutoDraw(True)
    
    # *key_resp* updates
    waitOnFlip = False
    if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp.frameNStart = frameN  # exact frame index
        key_resp.tStart = t  # local t and not account for scr refresh
        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
        key_resp.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp.status == STARTED and not waitOnFlip:
        theseKeys = key_resp.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_allKeys.extend(theseKeys)
        if len(_key_resp_allKeys):
            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
            key_resp.rt = _key_resp_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions1_PComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions1_P"-------
for thisComponent in Instructions1_PComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('textInstructions.started', textInstructions.tStartRefresh)
thisExp.addData('textInstructions.stopped', textInstructions.tStopRefresh)
thisExp.addData('textbox.started', textbox.tStartRefresh)
thisExp.addData('textbox.stopped', textbox.tStopRefresh)
# check responses
if key_resp.keys in ['', [], None]:  # No response was made
    key_resp.keys = None
thisExp.addData('key_resp.keys',key_resp.keys)
if key_resp.keys != None:  # we had a response
    thisExp.addData('key_resp.rt', key_resp.rt)
thisExp.addData('key_resp.started', key_resp.tStartRefresh)
thisExp.addData('key_resp.stopped', key_resp.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions1_P" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FS"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_31.keys = []
key_resp_31.rt = []
_key_resp_31_allKeys = []
# keep track of which components have finished
FSComponents = [fs1, key_resp_31]
for thisComponent in FSComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FS"-------
while continueRoutine:
    # get current time
    t = FSClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FSClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *fs1* updates
    if fs1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        fs1.frameNStart = frameN  # exact frame index
        fs1.tStart = t  # local t and not account for scr refresh
        fs1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(fs1, 'tStartRefresh')  # time at next scr refresh
        fs1.setAutoDraw(True)
    
    # *key_resp_31* updates
    waitOnFlip = False
    if key_resp_31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_31.frameNStart = frameN  # exact frame index
        key_resp_31.tStart = t  # local t and not account for scr refresh
        key_resp_31.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_31, 'tStartRefresh')  # time at next scr refresh
        key_resp_31.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_31.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_31.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_31.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_31.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_31_allKeys.extend(theseKeys)
        if len(_key_resp_31_allKeys):
            key_resp_31.keys = _key_resp_31_allKeys[-1].name  # just the last key pressed
            key_resp_31.rt = _key_resp_31_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FS"-------
for thisComponent in FSComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('fs1.started', fs1.tStartRefresh)
thisExp.addData('fs1.stopped', fs1.tStopRefresh)
# check responses
if key_resp_31.keys in ['', [], None]:  # No response was made
    key_resp_31.keys = None
thisExp.addData('key_resp_31.keys',key_resp_31.keys)
if key_resp_31.keys != None:  # we had a response
    thisExp.addData('key_resp_31.rt', key_resp_31.rt)
thisExp.addData('key_resp_31.started', key_resp_31.tStartRefresh)
thisExp.addData('key_resp_31.stopped', key_resp_31.tStopRefresh)
thisExp.nextEntry()
# the Routine "FS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Pract_Trial1 = data.TrialHandler(nReps=1.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block1.xlsx'),
    seed=None, name='Pract_Trial1')
thisExp.addLoop(Pract_Trial1)  # add the loop to the experiment
thisPract_Trial1 = Pract_Trial1.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPract_Trial1.rgb)
if thisPract_Trial1 != None:
    for paramName in thisPract_Trial1:
        exec('{} = thisPract_Trial1[paramName]'.format(paramName))

for thisPract_Trial1 in Pract_Trial1:
    currentLoop = Pract_Trial1
    # abbreviate parameter names if possible (e.g. rgb = thisPract_Trial1.rgb)
    if thisPract_Trial1 != None:
        for paramName in thisPract_Trial1:
            exec('{} = thisPract_Trial1[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "trial1p"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    textStudyWork.setText(Stimulus)
    key_resp_2.keys = []
    key_resp_2.rt = []
    _key_resp_2_allKeys = []
    myCount = myCount + 1
    if myCount == 24:
        Pract_Trial1.finished = True
    # keep track of which components have finished
    trial1pComponents = [Ex_Good, Bad, textStudyWork, key_resp_2]
    for thisComponent in trial1pComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    trial1pClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "trial1p"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = trial1pClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=trial1pClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Ex_Good* updates
        if Ex_Good.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Ex_Good.frameNStart = frameN  # exact frame index
            Ex_Good.tStart = t  # local t and not account for scr refresh
            Ex_Good.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Ex_Good, 'tStartRefresh')  # time at next scr refresh
            Ex_Good.setAutoDraw(True)
        if Ex_Good.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > Ex_Good.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                Ex_Good.tStop = t  # not accounting for scr refresh
                Ex_Good.frameNStop = frameN  # exact frame index
                win.timeOnFlip(Ex_Good, 'tStopRefresh')  # time at next scr refresh
                Ex_Good.setAutoDraw(False)
        
        # *Bad* updates
        if Bad.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Bad.frameNStart = frameN  # exact frame index
            Bad.tStart = t  # local t and not account for scr refresh
            Bad.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Bad, 'tStartRefresh')  # time at next scr refresh
            Bad.setAutoDraw(True)
        if Bad.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > Bad.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                Bad.tStop = t  # not accounting for scr refresh
                Bad.frameNStop = frameN  # exact frame index
                win.timeOnFlip(Bad, 'tStopRefresh')  # time at next scr refresh
                Bad.setAutoDraw(False)
        
        # *textStudyWork* updates
        if textStudyWork.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            textStudyWork.frameNStart = frameN  # exact frame index
            textStudyWork.tStart = t  # local t and not account for scr refresh
            textStudyWork.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textStudyWork, 'tStartRefresh')  # time at next scr refresh
            textStudyWork.setAutoDraw(True)
        if textStudyWork.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > textStudyWork.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                textStudyWork.tStop = t  # not accounting for scr refresh
                textStudyWork.frameNStop = frameN  # exact frame index
                win.timeOnFlip(textStudyWork, 'tStopRefresh')  # time at next scr refresh
                textStudyWork.setAutoDraw(False)
        
        # *key_resp_2* updates
        waitOnFlip = False
        if key_resp_2.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_2.frameNStart = frameN  # exact frame index
            key_resp_2.tStart = t  # local t and not account for scr refresh
            key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
            key_resp_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_2.tStop = t  # not accounting for scr refresh
                key_resp_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_2, 'tStopRefresh')  # time at next scr refresh
                key_resp_2.status = FINISHED
        if key_resp_2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_2.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_2_allKeys.extend(theseKeys)
            if len(_key_resp_2_allKeys):
                key_resp_2.keys = _key_resp_2_allKeys[0].name  # just the first key pressed
                key_resp_2.rt = _key_resp_2_allKeys[0].rt
                # was this correct?
                if (key_resp_2.keys == str(key)) or (key_resp_2.keys == key):
                    key_resp_2.corr = 1
                else:
                    key_resp_2.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in trial1pComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "trial1p"-------
    for thisComponent in trial1pComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial1.addData('Ex_Good.started', Ex_Good.tStartRefresh)
    Pract_Trial1.addData('Ex_Good.stopped', Ex_Good.tStopRefresh)
    Pract_Trial1.addData('Bad.started', Bad.tStartRefresh)
    Pract_Trial1.addData('Bad.stopped', Bad.tStopRefresh)
    Pract_Trial1.addData('textStudyWork.started', textStudyWork.tStartRefresh)
    Pract_Trial1.addData('textStudyWork.stopped', textStudyWork.tStopRefresh)
    # check responses
    if key_resp_2.keys in ['', [], None]:  # No response was made
        key_resp_2.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_2.corr = 1;  # correct non-response
        else:
           key_resp_2.corr = 0;  # failed to respond (incorrectly)
    # store data for Pract_Trial1 (TrialHandler)
    Pract_Trial1.addData('key_resp_2.keys',key_resp_2.keys)
    Pract_Trial1.addData('key_resp_2.corr', key_resp_2.corr)
    if key_resp_2.keys != None:  # we had a response
        Pract_Trial1.addData('key_resp_2.rt', key_resp_2.rt)
    Pract_Trial1.addData('key_resp_2.started', key_resp_2.tStartRefresh)
    Pract_Trial1.addData('key_resp_2.stopped', key_resp_2.tStopRefresh)
    
    # ------Prepare to start Routine "feedback1"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_2.corr:
        msg = "Correct"
    else:
        msg = "Wrong"
    text_13.setText(msg)
    # keep track of which components have finished
    feedback1Components = [text_13]
    for thisComponent in feedback1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    feedback1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "feedback1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = feedback1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=feedback1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_13* updates
        if text_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_13.frameNStart = frameN  # exact frame index
            text_13.tStart = t  # local t and not account for scr refresh
            text_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_13, 'tStartRefresh')  # time at next scr refresh
            text_13.setAutoDraw(True)
        if text_13.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_13.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_13.tStop = t  # not accounting for scr refresh
                text_13.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_13, 'tStopRefresh')  # time at next scr refresh
                text_13.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "feedback1"-------
    for thisComponent in feedback1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial1.addData('text_13.started', text_13.tStartRefresh)
    Pract_Trial1.addData('text_13.stopped', text_13.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'Pract_Trial1'


# ------Prepare to start Routine "Instructions1_T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_3.keys = []
key_resp_3.rt = []
_key_resp_3_allKeys = []
# keep track of which components have finished
Instructions1_TComponents = [TextInstructions, textbox2, key_resp_3]
for thisComponent in Instructions1_TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions1_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions1_T"-------
while continueRoutine:
    # get current time
    t = Instructions1_TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions1_TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *TextInstructions* updates
    if TextInstructions.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        TextInstructions.frameNStart = frameN  # exact frame index
        TextInstructions.tStart = t  # local t and not account for scr refresh
        TextInstructions.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(TextInstructions, 'tStartRefresh')  # time at next scr refresh
        TextInstructions.setAutoDraw(True)
    
    # *textbox2* updates
    if textbox2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox2.frameNStart = frameN  # exact frame index
        textbox2.tStart = t  # local t and not account for scr refresh
        textbox2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox2, 'tStartRefresh')  # time at next scr refresh
        textbox2.setAutoDraw(True)
    
    # *key_resp_3* updates
    waitOnFlip = False
    if key_resp_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_3.frameNStart = frameN  # exact frame index
        key_resp_3.tStart = t  # local t and not account for scr refresh
        key_resp_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_3, 'tStartRefresh')  # time at next scr refresh
        key_resp_3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_3.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_3.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_3_allKeys.extend(theseKeys)
        if len(_key_resp_3_allKeys):
            key_resp_3.keys = _key_resp_3_allKeys[-1].name  # just the last key pressed
            key_resp_3.rt = _key_resp_3_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions1_TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions1_T"-------
for thisComponent in Instructions1_TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('TextInstructions.started', TextInstructions.tStartRefresh)
thisExp.addData('TextInstructions.stopped', TextInstructions.tStopRefresh)
thisExp.addData('textbox2.started', textbox2.tStartRefresh)
thisExp.addData('textbox2.stopped', textbox2.tStopRefresh)
# check responses
if key_resp_3.keys in ['', [], None]:  # No response was made
    key_resp_3.keys = None
thisExp.addData('key_resp_3.keys',key_resp_3.keys)
if key_resp_3.keys != None:  # we had a response
    thisExp.addData('key_resp_3.rt', key_resp_3.rt)
thisExp.addData('key_resp_3.started', key_resp_3.tStartRefresh)
thisExp.addData('key_resp_3.stopped', key_resp_3.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions1_T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Study_Trial1 = data.TrialHandler(nReps=2.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block1.xlsx'),
    seed=None, name='Study_Trial1')
thisExp.addLoop(Study_Trial1)  # add the loop to the experiment
thisStudy_Trial1 = Study_Trial1.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial1.rgb)
if thisStudy_Trial1 != None:
    for paramName in thisStudy_Trial1:
        exec('{} = thisStudy_Trial1[paramName]'.format(paramName))

for thisStudy_Trial1 in Study_Trial1:
    currentLoop = Study_Trial1
    # abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial1.rgb)
    if thisStudy_Trial1 != None:
        for paramName in thisStudy_Trial1:
            exec('{} = thisStudy_Trial1[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "trial1t"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    txt_study.setText(Stimulus)
    key_resp_13.keys = []
    key_resp_13.rt = []
    _key_resp_13_allKeys = []
    myCount1 = myCount1 + 1
    if myCount1 == 72:
        Study_Trial1.finished = True
    # keep track of which components have finished
    trial1tComponents = [ExGood, txt_bad, txt_study, key_resp_13]
    for thisComponent in trial1tComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    trial1tClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "trial1t"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = trial1tClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=trial1tClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *ExGood* updates
        if ExGood.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            ExGood.frameNStart = frameN  # exact frame index
            ExGood.tStart = t  # local t and not account for scr refresh
            ExGood.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ExGood, 'tStartRefresh')  # time at next scr refresh
            ExGood.setAutoDraw(True)
        if ExGood.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > ExGood.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                ExGood.tStop = t  # not accounting for scr refresh
                ExGood.frameNStop = frameN  # exact frame index
                win.timeOnFlip(ExGood, 'tStopRefresh')  # time at next scr refresh
                ExGood.setAutoDraw(False)
        
        # *txt_bad* updates
        if txt_bad.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            txt_bad.frameNStart = frameN  # exact frame index
            txt_bad.tStart = t  # local t and not account for scr refresh
            txt_bad.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_bad, 'tStartRefresh')  # time at next scr refresh
            txt_bad.setAutoDraw(True)
        if txt_bad.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_bad.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                txt_bad.tStop = t  # not accounting for scr refresh
                txt_bad.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_bad, 'tStopRefresh')  # time at next scr refresh
                txt_bad.setAutoDraw(False)
        
        # *txt_study* updates
        if txt_study.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            txt_study.frameNStart = frameN  # exact frame index
            txt_study.tStart = t  # local t and not account for scr refresh
            txt_study.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_study, 'tStartRefresh')  # time at next scr refresh
            txt_study.setAutoDraw(True)
        if txt_study.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_study.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                txt_study.tStop = t  # not accounting for scr refresh
                txt_study.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_study, 'tStopRefresh')  # time at next scr refresh
                txt_study.setAutoDraw(False)
        
        # *key_resp_13* updates
        waitOnFlip = False
        if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_13.frameNStart = frameN  # exact frame index
            key_resp_13.tStart = t  # local t and not account for scr refresh
            key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
            key_resp_13.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_13.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_13.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_13.tStop = t  # not accounting for scr refresh
                key_resp_13.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_13, 'tStopRefresh')  # time at next scr refresh
                key_resp_13.status = FINISHED
        if key_resp_13.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_13.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_13_allKeys.extend(theseKeys)
            if len(_key_resp_13_allKeys):
                key_resp_13.keys = _key_resp_13_allKeys[0].name  # just the first key pressed
                key_resp_13.rt = _key_resp_13_allKeys[0].rt
                # was this correct?
                if (key_resp_13.keys == str(key)) or (key_resp_13.keys == key):
                    key_resp_13.corr = 1
                else:
                    key_resp_13.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in trial1tComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "trial1t"-------
    for thisComponent in trial1tComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Study_Trial1.addData('ExGood.started', ExGood.tStartRefresh)
    Study_Trial1.addData('ExGood.stopped', ExGood.tStopRefresh)
    Study_Trial1.addData('txt_bad.started', txt_bad.tStartRefresh)
    Study_Trial1.addData('txt_bad.stopped', txt_bad.tStopRefresh)
    Study_Trial1.addData('txt_study.started', txt_study.tStartRefresh)
    Study_Trial1.addData('txt_study.stopped', txt_study.tStopRefresh)
    # check responses
    if key_resp_13.keys in ['', [], None]:  # No response was made
        key_resp_13.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_13.corr = 1;  # correct non-response
        else:
           key_resp_13.corr = 0;  # failed to respond (incorrectly)
    # store data for Study_Trial1 (TrialHandler)
    Study_Trial1.addData('key_resp_13.keys',key_resp_13.keys)
    Study_Trial1.addData('key_resp_13.corr', key_resp_13.corr)
    if key_resp_13.keys != None:  # we had a response
        Study_Trial1.addData('key_resp_13.rt', key_resp_13.rt)
    Study_Trial1.addData('key_resp_13.started', key_resp_13.tStartRefresh)
    Study_Trial1.addData('key_resp_13.stopped', key_resp_13.tStopRefresh)
    thisExp.nextEntry()
    
# completed 2.0 repeats of 'Study_Trial1'


# ------Prepare to start Routine "Instructions2_P"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_4.keys = []
key_resp_4.rt = []
_key_resp_4_allKeys = []
# keep track of which components have finished
Instructions2_PComponents = [text_Instr, textbox3, key_resp_4]
for thisComponent in Instructions2_PComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions2_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions2_P"-------
while continueRoutine:
    # get current time
    t = Instructions2_PClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions2_PClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_Instr* updates
    if text_Instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Instr.frameNStart = frameN  # exact frame index
        text_Instr.tStart = t  # local t and not account for scr refresh
        text_Instr.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Instr, 'tStartRefresh')  # time at next scr refresh
        text_Instr.setAutoDraw(True)
    
    # *textbox3* updates
    if textbox3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox3.frameNStart = frameN  # exact frame index
        textbox3.tStart = t  # local t and not account for scr refresh
        textbox3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox3, 'tStartRefresh')  # time at next scr refresh
        textbox3.setAutoDraw(True)
    
    # *key_resp_4* updates
    waitOnFlip = False
    if key_resp_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_4.frameNStart = frameN  # exact frame index
        key_resp_4.tStart = t  # local t and not account for scr refresh
        key_resp_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_4, 'tStartRefresh')  # time at next scr refresh
        key_resp_4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_4.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_4.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_4_allKeys.extend(theseKeys)
        if len(_key_resp_4_allKeys):
            key_resp_4.keys = _key_resp_4_allKeys[-1].name  # just the last key pressed
            key_resp_4.rt = _key_resp_4_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions2_PComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions2_P"-------
for thisComponent in Instructions2_PComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_Instr.started', text_Instr.tStartRefresh)
thisExp.addData('text_Instr.stopped', text_Instr.tStopRefresh)
thisExp.addData('textbox3.started', textbox3.tStartRefresh)
thisExp.addData('textbox3.stopped', textbox3.tStopRefresh)
# check responses
if key_resp_4.keys in ['', [], None]:  # No response was made
    key_resp_4.keys = None
thisExp.addData('key_resp_4.keys',key_resp_4.keys)
if key_resp_4.keys != None:  # we had a response
    thisExp.addData('key_resp_4.rt', key_resp_4.rt)
thisExp.addData('key_resp_4.started', key_resp_4.tStartRefresh)
thisExp.addData('key_resp_4.stopped', key_resp_4.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions2_P" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Pract_Trial2 = data.TrialHandler(nReps=1.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block2.xlsx'),
    seed=None, name='Pract_Trial2')
thisExp.addLoop(Pract_Trial2)  # add the loop to the experiment
thisPract_Trial2 = Pract_Trial2.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPract_Trial2.rgb)
if thisPract_Trial2 != None:
    for paramName in thisPract_Trial2:
        exec('{} = thisPract_Trial2[paramName]'.format(paramName))

for thisPract_Trial2 in Pract_Trial2:
    currentLoop = Pract_Trial2
    # abbreviate parameter names if possible (e.g. rgb = thisPract_Trial2.rgb)
    if thisPract_Trial2 != None:
        for paramName in thisPract_Trial2:
            exec('{} = thisPract_Trial2[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "trial2p"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    SCIAT.setText(Stimulus)
    key_resp_5.keys = []
    key_resp_5.rt = []
    _key_resp_5_allKeys = []
    myCount2 = myCount2 + 1
    if myCount2 == 24:
        Pract_Trial2.finished = True
    # keep track of which components have finished
    trial2pComponents = [Ex_Bad, Good, SCIAT, key_resp_5]
    for thisComponent in trial2pComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    trial2pClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "trial2p"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = trial2pClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=trial2pClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Ex_Bad* updates
        if Ex_Bad.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Ex_Bad.frameNStart = frameN  # exact frame index
            Ex_Bad.tStart = t  # local t and not account for scr refresh
            Ex_Bad.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Ex_Bad, 'tStartRefresh')  # time at next scr refresh
            Ex_Bad.setAutoDraw(True)
        if Ex_Bad.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > Ex_Bad.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                Ex_Bad.tStop = t  # not accounting for scr refresh
                Ex_Bad.frameNStop = frameN  # exact frame index
                win.timeOnFlip(Ex_Bad, 'tStopRefresh')  # time at next scr refresh
                Ex_Bad.setAutoDraw(False)
        
        # *Good* updates
        if Good.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Good.frameNStart = frameN  # exact frame index
            Good.tStart = t  # local t and not account for scr refresh
            Good.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Good, 'tStartRefresh')  # time at next scr refresh
            Good.setAutoDraw(True)
        if Good.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > Good.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                Good.tStop = t  # not accounting for scr refresh
                Good.frameNStop = frameN  # exact frame index
                win.timeOnFlip(Good, 'tStopRefresh')  # time at next scr refresh
                Good.setAutoDraw(False)
        
        # *SCIAT* updates
        if SCIAT.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            SCIAT.frameNStart = frameN  # exact frame index
            SCIAT.tStart = t  # local t and not account for scr refresh
            SCIAT.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SCIAT, 'tStartRefresh')  # time at next scr refresh
            SCIAT.setAutoDraw(True)
        if SCIAT.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > SCIAT.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                SCIAT.tStop = t  # not accounting for scr refresh
                SCIAT.frameNStop = frameN  # exact frame index
                win.timeOnFlip(SCIAT, 'tStopRefresh')  # time at next scr refresh
                SCIAT.setAutoDraw(False)
        
        # *key_resp_5* updates
        waitOnFlip = False
        if key_resp_5.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_5.frameNStart = frameN  # exact frame index
            key_resp_5.tStart = t  # local t and not account for scr refresh
            key_resp_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_5, 'tStartRefresh')  # time at next scr refresh
            key_resp_5.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_5.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_5.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_5.tStop = t  # not accounting for scr refresh
                key_resp_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_5, 'tStopRefresh')  # time at next scr refresh
                key_resp_5.status = FINISHED
        if key_resp_5.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_5.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_5_allKeys.extend(theseKeys)
            if len(_key_resp_5_allKeys):
                key_resp_5.keys = _key_resp_5_allKeys[0].name  # just the first key pressed
                key_resp_5.rt = _key_resp_5_allKeys[0].rt
                # was this correct?
                if (key_resp_5.keys == str(key)) or (key_resp_5.keys == key):
                    key_resp_5.corr = 1
                else:
                    key_resp_5.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in trial2pComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "trial2p"-------
    for thisComponent in trial2pComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial2.addData('Ex_Bad.started', Ex_Bad.tStartRefresh)
    Pract_Trial2.addData('Ex_Bad.stopped', Ex_Bad.tStopRefresh)
    Pract_Trial2.addData('Good.started', Good.tStartRefresh)
    Pract_Trial2.addData('Good.stopped', Good.tStopRefresh)
    Pract_Trial2.addData('SCIAT.started', SCIAT.tStartRefresh)
    Pract_Trial2.addData('SCIAT.stopped', SCIAT.tStopRefresh)
    # check responses
    if key_resp_5.keys in ['', [], None]:  # No response was made
        key_resp_5.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_5.corr = 1;  # correct non-response
        else:
           key_resp_5.corr = 0;  # failed to respond (incorrectly)
    # store data for Pract_Trial2 (TrialHandler)
    Pract_Trial2.addData('key_resp_5.keys',key_resp_5.keys)
    Pract_Trial2.addData('key_resp_5.corr', key_resp_5.corr)
    if key_resp_5.keys != None:  # we had a response
        Pract_Trial2.addData('key_resp_5.rt', key_resp_5.rt)
    Pract_Trial2.addData('key_resp_5.started', key_resp_5.tStartRefresh)
    Pract_Trial2.addData('key_resp_5.stopped', key_resp_5.tStopRefresh)
    
    # ------Prepare to start Routine "feedback2"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_5.corr:
        msg1 = "Correct"
    else:
        msg1 = "Wrong"
    text_14.setText(msg1)
    # keep track of which components have finished
    feedback2Components = [text_14]
    for thisComponent in feedback2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    feedback2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "feedback2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = feedback2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=feedback2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_14* updates
        if text_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_14.frameNStart = frameN  # exact frame index
            text_14.tStart = t  # local t and not account for scr refresh
            text_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_14, 'tStartRefresh')  # time at next scr refresh
            text_14.setAutoDraw(True)
        if text_14.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_14.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_14.tStop = t  # not accounting for scr refresh
                text_14.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_14, 'tStopRefresh')  # time at next scr refresh
                text_14.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "feedback2"-------
    for thisComponent in feedback2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial2.addData('text_14.started', text_14.tStartRefresh)
    Pract_Trial2.addData('text_14.stopped', text_14.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'Pract_Trial2'


# ------Prepare to start Routine "Instructions2_T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_6.keys = []
key_resp_6.rt = []
_key_resp_6_allKeys = []
# keep track of which components have finished
Instructions2_TComponents = [instr, textbox3_2, key_resp_6]
for thisComponent in Instructions2_TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions2_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions2_T"-------
while continueRoutine:
    # get current time
    t = Instructions2_TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions2_TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *instr* updates
    if instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        instr.frameNStart = frameN  # exact frame index
        instr.tStart = t  # local t and not account for scr refresh
        instr.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(instr, 'tStartRefresh')  # time at next scr refresh
        instr.setAutoDraw(True)
    
    # *textbox3_2* updates
    if textbox3_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox3_2.frameNStart = frameN  # exact frame index
        textbox3_2.tStart = t  # local t and not account for scr refresh
        textbox3_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox3_2, 'tStartRefresh')  # time at next scr refresh
        textbox3_2.setAutoDraw(True)
    
    # *key_resp_6* updates
    waitOnFlip = False
    if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_6.frameNStart = frameN  # exact frame index
        key_resp_6.tStart = t  # local t and not account for scr refresh
        key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
        key_resp_6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_6.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_6.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_6_allKeys.extend(theseKeys)
        if len(_key_resp_6_allKeys):
            key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
            key_resp_6.rt = _key_resp_6_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions2_TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions2_T"-------
for thisComponent in Instructions2_TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('instr.started', instr.tStartRefresh)
thisExp.addData('instr.stopped', instr.tStopRefresh)
thisExp.addData('textbox3_2.started', textbox3_2.tStartRefresh)
thisExp.addData('textbox3_2.stopped', textbox3_2.tStopRefresh)
# check responses
if key_resp_6.keys in ['', [], None]:  # No response was made
    key_resp_6.keys = None
thisExp.addData('key_resp_6.keys',key_resp_6.keys)
if key_resp_6.keys != None:  # we had a response
    thisExp.addData('key_resp_6.rt', key_resp_6.rt)
thisExp.addData('key_resp_6.started', key_resp_6.tStartRefresh)
thisExp.addData('key_resp_6.stopped', key_resp_6.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions2_T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Study_Trial2 = data.TrialHandler(nReps=2.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block2.xlsx'),
    seed=None, name='Study_Trial2')
thisExp.addLoop(Study_Trial2)  # add the loop to the experiment
thisStudy_Trial2 = Study_Trial2.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial2.rgb)
if thisStudy_Trial2 != None:
    for paramName in thisStudy_Trial2:
        exec('{} = thisStudy_Trial2[paramName]'.format(paramName))

for thisStudy_Trial2 in Study_Trial2:
    currentLoop = Study_Trial2
    # abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial2.rgb)
    if thisStudy_Trial2 != None:
        for paramName in thisStudy_Trial2:
            exec('{} = thisStudy_Trial2[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "trial2t"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    txt_Studywords.setText(Stimulus)
    key_resp_14.keys = []
    key_resp_14.rt = []
    _key_resp_14_allKeys = []
    myCount3 = myCount3 + 1
    if myCount3 == 72:
        Study_Trial2.finished = True
    # keep track of which components have finished
    trial2tComponents = [Txt_ExBad, txt_good, txt_Studywords, key_resp_14]
    for thisComponent in trial2tComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    trial2tClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "trial2t"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = trial2tClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=trial2tClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *Txt_ExBad* updates
        if Txt_ExBad.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            Txt_ExBad.frameNStart = frameN  # exact frame index
            Txt_ExBad.tStart = t  # local t and not account for scr refresh
            Txt_ExBad.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(Txt_ExBad, 'tStartRefresh')  # time at next scr refresh
            Txt_ExBad.setAutoDraw(True)
        if Txt_ExBad.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > Txt_ExBad.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                Txt_ExBad.tStop = t  # not accounting for scr refresh
                Txt_ExBad.frameNStop = frameN  # exact frame index
                win.timeOnFlip(Txt_ExBad, 'tStopRefresh')  # time at next scr refresh
                Txt_ExBad.setAutoDraw(False)
        
        # *txt_good* updates
        if txt_good.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            txt_good.frameNStart = frameN  # exact frame index
            txt_good.tStart = t  # local t and not account for scr refresh
            txt_good.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_good, 'tStartRefresh')  # time at next scr refresh
            txt_good.setAutoDraw(True)
        if txt_good.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_good.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                txt_good.tStop = t  # not accounting for scr refresh
                txt_good.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_good, 'tStopRefresh')  # time at next scr refresh
                txt_good.setAutoDraw(False)
        
        # *txt_Studywords* updates
        if txt_Studywords.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            txt_Studywords.frameNStart = frameN  # exact frame index
            txt_Studywords.tStart = t  # local t and not account for scr refresh
            txt_Studywords.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_Studywords, 'tStartRefresh')  # time at next scr refresh
            txt_Studywords.setAutoDraw(True)
        if txt_Studywords.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_Studywords.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                txt_Studywords.tStop = t  # not accounting for scr refresh
                txt_Studywords.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_Studywords, 'tStopRefresh')  # time at next scr refresh
                txt_Studywords.setAutoDraw(False)
        
        # *key_resp_14* updates
        waitOnFlip = False
        if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_14.frameNStart = frameN  # exact frame index
            key_resp_14.tStart = t  # local t and not account for scr refresh
            key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
            key_resp_14.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_14.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_14.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_14.tStop = t  # not accounting for scr refresh
                key_resp_14.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_14, 'tStopRefresh')  # time at next scr refresh
                key_resp_14.status = FINISHED
        if key_resp_14.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_14.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_14_allKeys.extend(theseKeys)
            if len(_key_resp_14_allKeys):
                key_resp_14.keys = _key_resp_14_allKeys[0].name  # just the first key pressed
                key_resp_14.rt = _key_resp_14_allKeys[0].rt
                # was this correct?
                if (key_resp_14.keys == str(key)) or (key_resp_14.keys == key):
                    key_resp_14.corr = 1
                else:
                    key_resp_14.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in trial2tComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "trial2t"-------
    for thisComponent in trial2tComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Study_Trial2.addData('Txt_ExBad.started', Txt_ExBad.tStartRefresh)
    Study_Trial2.addData('Txt_ExBad.stopped', Txt_ExBad.tStopRefresh)
    Study_Trial2.addData('txt_good.started', txt_good.tStartRefresh)
    Study_Trial2.addData('txt_good.stopped', txt_good.tStopRefresh)
    Study_Trial2.addData('txt_Studywords.started', txt_Studywords.tStartRefresh)
    Study_Trial2.addData('txt_Studywords.stopped', txt_Studywords.tStopRefresh)
    # check responses
    if key_resp_14.keys in ['', [], None]:  # No response was made
        key_resp_14.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_14.corr = 1;  # correct non-response
        else:
           key_resp_14.corr = 0;  # failed to respond (incorrectly)
    # store data for Study_Trial2 (TrialHandler)
    Study_Trial2.addData('key_resp_14.keys',key_resp_14.keys)
    Study_Trial2.addData('key_resp_14.corr', key_resp_14.corr)
    if key_resp_14.keys != None:  # we had a response
        Study_Trial2.addData('key_resp_14.rt', key_resp_14.rt)
    Study_Trial2.addData('key_resp_14.started', key_resp_14.tStartRefresh)
    Study_Trial2.addData('key_resp_14.stopped', key_resp_14.tStopRefresh)
    thisExp.nextEntry()
    
# completed 2.0 repeats of 'Study_Trial2'


# ------Prepare to start Routine "Instructions3_P"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_7.keys = []
key_resp_7.rt = []
_key_resp_7_allKeys = []
# keep track of which components have finished
Instructions3_PComponents = [text_3, textbox4, key_resp_7]
for thisComponent in Instructions3_PComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions3_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions3_P"-------
while continueRoutine:
    # get current time
    t = Instructions3_PClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions3_PClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_3* updates
    if text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_3.frameNStart = frameN  # exact frame index
        text_3.tStart = t  # local t and not account for scr refresh
        text_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_3, 'tStartRefresh')  # time at next scr refresh
        text_3.setAutoDraw(True)
    
    # *textbox4* updates
    if textbox4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox4.frameNStart = frameN  # exact frame index
        textbox4.tStart = t  # local t and not account for scr refresh
        textbox4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox4, 'tStartRefresh')  # time at next scr refresh
        textbox4.setAutoDraw(True)
    
    # *key_resp_7* updates
    waitOnFlip = False
    if key_resp_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_7.frameNStart = frameN  # exact frame index
        key_resp_7.tStart = t  # local t and not account for scr refresh
        key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
        key_resp_7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_7.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_7.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_7_allKeys.extend(theseKeys)
        if len(_key_resp_7_allKeys):
            key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
            key_resp_7.rt = _key_resp_7_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions3_PComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions3_P"-------
for thisComponent in Instructions3_PComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_3.started', text_3.tStartRefresh)
thisExp.addData('text_3.stopped', text_3.tStopRefresh)
thisExp.addData('textbox4.started', textbox4.tStartRefresh)
thisExp.addData('textbox4.stopped', textbox4.tStopRefresh)
# check responses
if key_resp_7.keys in ['', [], None]:  # No response was made
    key_resp_7.keys = None
thisExp.addData('key_resp_7.keys',key_resp_7.keys)
if key_resp_7.keys != None:  # we had a response
    thisExp.addData('key_resp_7.rt', key_resp_7.rt)
thisExp.addData('key_resp_7.started', key_resp_7.tStartRefresh)
thisExp.addData('key_resp_7.stopped', key_resp_7.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions3_P" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Pract_Trial3 = data.TrialHandler(nReps=1.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block3.xlsx'),
    seed=None, name='Pract_Trial3')
thisExp.addLoop(Pract_Trial3)  # add the loop to the experiment
thisPract_Trial3 = Pract_Trial3.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPract_Trial3.rgb)
if thisPract_Trial3 != None:
    for paramName in thisPract_Trial3:
        exec('{} = thisPract_Trial3[paramName]'.format(paramName))

for thisPract_Trial3 in Pract_Trial3:
    currentLoop = Pract_Trial3
    # abbreviate parameter names if possible (e.g. rgb = thisPract_Trial3.rgb)
    if thisPract_Trial3 != None:
        for paramName in thisPract_Trial3:
            exec('{} = thisPract_Trial3[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "Trial3p"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    text_SCIAT.setText(Stimulus)
    key_resp_11.keys = []
    key_resp_11.rt = []
    _key_resp_11_allKeys = []
    myCount4 = myCount4 + 1
    if myCount4 == 24:
        Pract_Trial3.finished = True
    # keep track of which components have finished
    Trial3pComponents = [text_bad, text_ExGood, text_SCIAT, key_resp_11]
    for thisComponent in Trial3pComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Trial3pClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Trial3p"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Trial3pClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Trial3pClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_bad* updates
        if text_bad.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_bad.frameNStart = frameN  # exact frame index
            text_bad.tStart = t  # local t and not account for scr refresh
            text_bad.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_bad, 'tStartRefresh')  # time at next scr refresh
            text_bad.setAutoDraw(True)
        if text_bad.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_bad.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                text_bad.tStop = t  # not accounting for scr refresh
                text_bad.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_bad, 'tStopRefresh')  # time at next scr refresh
                text_bad.setAutoDraw(False)
        
        # *text_ExGood* updates
        if text_ExGood.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_ExGood.frameNStart = frameN  # exact frame index
            text_ExGood.tStart = t  # local t and not account for scr refresh
            text_ExGood.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_ExGood, 'tStartRefresh')  # time at next scr refresh
            text_ExGood.setAutoDraw(True)
        if text_ExGood.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_ExGood.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                text_ExGood.tStop = t  # not accounting for scr refresh
                text_ExGood.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_ExGood, 'tStopRefresh')  # time at next scr refresh
                text_ExGood.setAutoDraw(False)
        
        # *text_SCIAT* updates
        if text_SCIAT.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            text_SCIAT.frameNStart = frameN  # exact frame index
            text_SCIAT.tStart = t  # local t and not account for scr refresh
            text_SCIAT.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_SCIAT, 'tStartRefresh')  # time at next scr refresh
            text_SCIAT.setAutoDraw(True)
        if text_SCIAT.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_SCIAT.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                text_SCIAT.tStop = t  # not accounting for scr refresh
                text_SCIAT.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_SCIAT, 'tStopRefresh')  # time at next scr refresh
                text_SCIAT.setAutoDraw(False)
        
        # *key_resp_11* updates
        waitOnFlip = False
        if key_resp_11.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_11.frameNStart = frameN  # exact frame index
            key_resp_11.tStart = t  # local t and not account for scr refresh
            key_resp_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_11, 'tStartRefresh')  # time at next scr refresh
            key_resp_11.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_11.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_11.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_11.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_11.tStop = t  # not accounting for scr refresh
                key_resp_11.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_11, 'tStopRefresh')  # time at next scr refresh
                key_resp_11.status = FINISHED
        if key_resp_11.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_11.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_11_allKeys.extend(theseKeys)
            if len(_key_resp_11_allKeys):
                key_resp_11.keys = _key_resp_11_allKeys[0].name  # just the first key pressed
                key_resp_11.rt = _key_resp_11_allKeys[0].rt
                # was this correct?
                if (key_resp_11.keys == str(key)) or (key_resp_11.keys == key):
                    key_resp_11.corr = 1
                else:
                    key_resp_11.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Trial3pComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Trial3p"-------
    for thisComponent in Trial3pComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial3.addData('text_bad.started', text_bad.tStartRefresh)
    Pract_Trial3.addData('text_bad.stopped', text_bad.tStopRefresh)
    Pract_Trial3.addData('text_ExGood.started', text_ExGood.tStartRefresh)
    Pract_Trial3.addData('text_ExGood.stopped', text_ExGood.tStopRefresh)
    Pract_Trial3.addData('text_SCIAT.started', text_SCIAT.tStartRefresh)
    Pract_Trial3.addData('text_SCIAT.stopped', text_SCIAT.tStopRefresh)
    # check responses
    if key_resp_11.keys in ['', [], None]:  # No response was made
        key_resp_11.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_11.corr = 1;  # correct non-response
        else:
           key_resp_11.corr = 0;  # failed to respond (incorrectly)
    # store data for Pract_Trial3 (TrialHandler)
    Pract_Trial3.addData('key_resp_11.keys',key_resp_11.keys)
    Pract_Trial3.addData('key_resp_11.corr', key_resp_11.corr)
    if key_resp_11.keys != None:  # we had a response
        Pract_Trial3.addData('key_resp_11.rt', key_resp_11.rt)
    Pract_Trial3.addData('key_resp_11.started', key_resp_11.tStartRefresh)
    Pract_Trial3.addData('key_resp_11.stopped', key_resp_11.tStopRefresh)
    
    # ------Prepare to start Routine "feedback3"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_11.corr:
        msg2 = "Correct"
    else:
        msg2 = "Wrong"
    text_15.setText(msg2)
    # keep track of which components have finished
    feedback3Components = [text_15]
    for thisComponent in feedback3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    feedback3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "feedback3"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = feedback3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=feedback3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_15* updates
        if text_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_15.frameNStart = frameN  # exact frame index
            text_15.tStart = t  # local t and not account for scr refresh
            text_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_15, 'tStartRefresh')  # time at next scr refresh
            text_15.setAutoDraw(True)
        if text_15.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_15.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_15.tStop = t  # not accounting for scr refresh
                text_15.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_15, 'tStopRefresh')  # time at next scr refresh
                text_15.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "feedback3"-------
    for thisComponent in feedback3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial3.addData('text_15.started', text_15.tStartRefresh)
    Pract_Trial3.addData('text_15.stopped', text_15.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'Pract_Trial3'


# ------Prepare to start Routine "Instructions3_T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_8.keys = []
key_resp_8.rt = []
_key_resp_8_allKeys = []
# keep track of which components have finished
Instructions3_TComponents = [text_4, textbox4_2, key_resp_8]
for thisComponent in Instructions3_TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions3_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions3_T"-------
while continueRoutine:
    # get current time
    t = Instructions3_TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions3_TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_4* updates
    if text_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_4.frameNStart = frameN  # exact frame index
        text_4.tStart = t  # local t and not account for scr refresh
        text_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_4, 'tStartRefresh')  # time at next scr refresh
        text_4.setAutoDraw(True)
    
    # *textbox4_2* updates
    if textbox4_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox4_2.frameNStart = frameN  # exact frame index
        textbox4_2.tStart = t  # local t and not account for scr refresh
        textbox4_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox4_2, 'tStartRefresh')  # time at next scr refresh
        textbox4_2.setAutoDraw(True)
    
    # *key_resp_8* updates
    waitOnFlip = False
    if key_resp_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_8.frameNStart = frameN  # exact frame index
        key_resp_8.tStart = t  # local t and not account for scr refresh
        key_resp_8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_8, 'tStartRefresh')  # time at next scr refresh
        key_resp_8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_8.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_8.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_8_allKeys.extend(theseKeys)
        if len(_key_resp_8_allKeys):
            key_resp_8.keys = _key_resp_8_allKeys[-1].name  # just the last key pressed
            key_resp_8.rt = _key_resp_8_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions3_TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions3_T"-------
for thisComponent in Instructions3_TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_4.started', text_4.tStartRefresh)
thisExp.addData('text_4.stopped', text_4.tStopRefresh)
thisExp.addData('textbox4_2.started', textbox4_2.tStartRefresh)
thisExp.addData('textbox4_2.stopped', textbox4_2.tStopRefresh)
# check responses
if key_resp_8.keys in ['', [], None]:  # No response was made
    key_resp_8.keys = None
thisExp.addData('key_resp_8.keys',key_resp_8.keys)
if key_resp_8.keys != None:  # we had a response
    thisExp.addData('key_resp_8.rt', key_resp_8.rt)
thisExp.addData('key_resp_8.started', key_resp_8.tStartRefresh)
thisExp.addData('key_resp_8.stopped', key_resp_8.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions3_T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Study_Trial3 = data.TrialHandler(nReps=2.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block3.xlsx'),
    seed=None, name='Study_Trial3')
thisExp.addLoop(Study_Trial3)  # add the loop to the experiment
thisStudy_Trial3 = Study_Trial3.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial3.rgb)
if thisStudy_Trial3 != None:
    for paramName in thisStudy_Trial3:
        exec('{} = thisStudy_Trial3[paramName]'.format(paramName))

for thisStudy_Trial3 in Study_Trial3:
    currentLoop = Study_Trial3
    # abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial3.rgb)
    if thisStudy_Trial3 != None:
        for paramName in thisStudy_Trial3:
            exec('{} = thisStudy_Trial3[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "trial3t"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    txt_SCIAT.setText(Stimulus)
    key_resp_15.keys = []
    key_resp_15.rt = []
    _key_resp_15_allKeys = []
    myCount5 = myCount5 + 1
    if myCount5 == 72:
        Study_Trial3.finished = True
    # keep track of which components have finished
    trial3tComponents = [textbad, txt_ExGood, txt_SCIAT, key_resp_15]
    for thisComponent in trial3tComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    trial3tClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "trial3t"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = trial3tClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=trial3tClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *textbad* updates
        if textbad.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textbad.frameNStart = frameN  # exact frame index
            textbad.tStart = t  # local t and not account for scr refresh
            textbad.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textbad, 'tStartRefresh')  # time at next scr refresh
            textbad.setAutoDraw(True)
        if textbad.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > textbad.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                textbad.tStop = t  # not accounting for scr refresh
                textbad.frameNStop = frameN  # exact frame index
                win.timeOnFlip(textbad, 'tStopRefresh')  # time at next scr refresh
                textbad.setAutoDraw(False)
        
        # *txt_ExGood* updates
        if txt_ExGood.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            txt_ExGood.frameNStart = frameN  # exact frame index
            txt_ExGood.tStart = t  # local t and not account for scr refresh
            txt_ExGood.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_ExGood, 'tStartRefresh')  # time at next scr refresh
            txt_ExGood.setAutoDraw(True)
        if txt_ExGood.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_ExGood.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                txt_ExGood.tStop = t  # not accounting for scr refresh
                txt_ExGood.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_ExGood, 'tStopRefresh')  # time at next scr refresh
                txt_ExGood.setAutoDraw(False)
        
        # *txt_SCIAT* updates
        if txt_SCIAT.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            txt_SCIAT.frameNStart = frameN  # exact frame index
            txt_SCIAT.tStart = t  # local t and not account for scr refresh
            txt_SCIAT.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_SCIAT, 'tStartRefresh')  # time at next scr refresh
            txt_SCIAT.setAutoDraw(True)
        if txt_SCIAT.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_SCIAT.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                txt_SCIAT.tStop = t  # not accounting for scr refresh
                txt_SCIAT.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_SCIAT, 'tStopRefresh')  # time at next scr refresh
                txt_SCIAT.setAutoDraw(False)
        
        # *key_resp_15* updates
        waitOnFlip = False
        if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_15.frameNStart = frameN  # exact frame index
            key_resp_15.tStart = t  # local t and not account for scr refresh
            key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
            key_resp_15.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_15.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_15.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_15.tStop = t  # not accounting for scr refresh
                key_resp_15.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_15, 'tStopRefresh')  # time at next scr refresh
                key_resp_15.status = FINISHED
        if key_resp_15.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_15.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_15_allKeys.extend(theseKeys)
            if len(_key_resp_15_allKeys):
                key_resp_15.keys = _key_resp_15_allKeys[0].name  # just the first key pressed
                key_resp_15.rt = _key_resp_15_allKeys[0].rt
                # was this correct?
                if (key_resp_15.keys == str(key)) or (key_resp_15.keys == key):
                    key_resp_15.corr = 1
                else:
                    key_resp_15.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in trial3tComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "trial3t"-------
    for thisComponent in trial3tComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Study_Trial3.addData('textbad.started', textbad.tStartRefresh)
    Study_Trial3.addData('textbad.stopped', textbad.tStopRefresh)
    Study_Trial3.addData('txt_ExGood.started', txt_ExGood.tStartRefresh)
    Study_Trial3.addData('txt_ExGood.stopped', txt_ExGood.tStopRefresh)
    Study_Trial3.addData('txt_SCIAT.started', txt_SCIAT.tStartRefresh)
    Study_Trial3.addData('txt_SCIAT.stopped', txt_SCIAT.tStopRefresh)
    # check responses
    if key_resp_15.keys in ['', [], None]:  # No response was made
        key_resp_15.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_15.corr = 1;  # correct non-response
        else:
           key_resp_15.corr = 0;  # failed to respond (incorrectly)
    # store data for Study_Trial3 (TrialHandler)
    Study_Trial3.addData('key_resp_15.keys',key_resp_15.keys)
    Study_Trial3.addData('key_resp_15.corr', key_resp_15.corr)
    if key_resp_15.keys != None:  # we had a response
        Study_Trial3.addData('key_resp_15.rt', key_resp_15.rt)
    Study_Trial3.addData('key_resp_15.started', key_resp_15.tStartRefresh)
    Study_Trial3.addData('key_resp_15.stopped', key_resp_15.tStopRefresh)
    thisExp.nextEntry()
    
# completed 2.0 repeats of 'Study_Trial3'


# ------Prepare to start Routine "Instructions4_P"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_9.keys = []
key_resp_9.rt = []
_key_resp_9_allKeys = []
# keep track of which components have finished
Instructions4_PComponents = [text_5, textbox5, key_resp_9]
for thisComponent in Instructions4_PComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions4_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions4_P"-------
while continueRoutine:
    # get current time
    t = Instructions4_PClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions4_PClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_5* updates
    if text_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_5.frameNStart = frameN  # exact frame index
        text_5.tStart = t  # local t and not account for scr refresh
        text_5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_5, 'tStartRefresh')  # time at next scr refresh
        text_5.setAutoDraw(True)
    
    # *textbox5* updates
    if textbox5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox5.frameNStart = frameN  # exact frame index
        textbox5.tStart = t  # local t and not account for scr refresh
        textbox5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox5, 'tStartRefresh')  # time at next scr refresh
        textbox5.setAutoDraw(True)
    
    # *key_resp_9* updates
    waitOnFlip = False
    if key_resp_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_9.frameNStart = frameN  # exact frame index
        key_resp_9.tStart = t  # local t and not account for scr refresh
        key_resp_9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_9, 'tStartRefresh')  # time at next scr refresh
        key_resp_9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_9.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_9.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_9_allKeys.extend(theseKeys)
        if len(_key_resp_9_allKeys):
            key_resp_9.keys = _key_resp_9_allKeys[-1].name  # just the last key pressed
            key_resp_9.rt = _key_resp_9_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions4_PComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions4_P"-------
for thisComponent in Instructions4_PComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_5.started', text_5.tStartRefresh)
thisExp.addData('text_5.stopped', text_5.tStopRefresh)
thisExp.addData('textbox5.started', textbox5.tStartRefresh)
thisExp.addData('textbox5.stopped', textbox5.tStopRefresh)
# check responses
if key_resp_9.keys in ['', [], None]:  # No response was made
    key_resp_9.keys = None
thisExp.addData('key_resp_9.keys',key_resp_9.keys)
if key_resp_9.keys != None:  # we had a response
    thisExp.addData('key_resp_9.rt', key_resp_9.rt)
thisExp.addData('key_resp_9.started', key_resp_9.tStartRefresh)
thisExp.addData('key_resp_9.stopped', key_resp_9.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions4_P" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Pract_Trial4 = data.TrialHandler(nReps=1.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block4.xlsx'),
    seed=None, name='Pract_Trial4')
thisExp.addLoop(Pract_Trial4)  # add the loop to the experiment
thisPract_Trial4 = Pract_Trial4.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPract_Trial4.rgb)
if thisPract_Trial4 != None:
    for paramName in thisPract_Trial4:
        exec('{} = thisPract_Trial4[paramName]'.format(paramName))

for thisPract_Trial4 in Pract_Trial4:
    currentLoop = Pract_Trial4
    # abbreviate parameter names if possible (e.g. rgb = thisPract_Trial4.rgb)
    if thisPract_Trial4 != None:
        for paramName in thisPract_Trial4:
            exec('{} = thisPract_Trial4[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "Trial4p"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    text_SC_IAT.setText(Stimulus)
    key_resp_12.keys = []
    key_resp_12.rt = []
    _key_resp_12_allKeys = []
    myCount6 = myCount6 + 1
    if myCount6 == 24:
        Pract_Trial4.finished = True
    # keep track of which components have finished
    Trial4pComponents = [good, ExNeg, text_SC_IAT, key_resp_12]
    for thisComponent in Trial4pComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Trial4pClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Trial4p"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Trial4pClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Trial4pClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *good* updates
        if good.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            good.frameNStart = frameN  # exact frame index
            good.tStart = t  # local t and not account for scr refresh
            good.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(good, 'tStartRefresh')  # time at next scr refresh
            good.setAutoDraw(True)
        if good.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > good.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                good.tStop = t  # not accounting for scr refresh
                good.frameNStop = frameN  # exact frame index
                win.timeOnFlip(good, 'tStopRefresh')  # time at next scr refresh
                good.setAutoDraw(False)
        
        # *ExNeg* updates
        if ExNeg.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            ExNeg.frameNStart = frameN  # exact frame index
            ExNeg.tStart = t  # local t and not account for scr refresh
            ExNeg.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(ExNeg, 'tStartRefresh')  # time at next scr refresh
            ExNeg.setAutoDraw(True)
        if ExNeg.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > ExNeg.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                ExNeg.tStop = t  # not accounting for scr refresh
                ExNeg.frameNStop = frameN  # exact frame index
                win.timeOnFlip(ExNeg, 'tStopRefresh')  # time at next scr refresh
                ExNeg.setAutoDraw(False)
        
        # *text_SC_IAT* updates
        if text_SC_IAT.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            text_SC_IAT.frameNStart = frameN  # exact frame index
            text_SC_IAT.tStart = t  # local t and not account for scr refresh
            text_SC_IAT.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_SC_IAT, 'tStartRefresh')  # time at next scr refresh
            text_SC_IAT.setAutoDraw(True)
        if text_SC_IAT.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_SC_IAT.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                text_SC_IAT.tStop = t  # not accounting for scr refresh
                text_SC_IAT.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_SC_IAT, 'tStopRefresh')  # time at next scr refresh
                text_SC_IAT.setAutoDraw(False)
        
        # *key_resp_12* updates
        waitOnFlip = False
        if key_resp_12.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_12.frameNStart = frameN  # exact frame index
            key_resp_12.tStart = t  # local t and not account for scr refresh
            key_resp_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_12, 'tStartRefresh')  # time at next scr refresh
            key_resp_12.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_12.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_12.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_12.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_12.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_12.tStop = t  # not accounting for scr refresh
                key_resp_12.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_12, 'tStopRefresh')  # time at next scr refresh
                key_resp_12.status = FINISHED
        if key_resp_12.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_12.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_12_allKeys.extend(theseKeys)
            if len(_key_resp_12_allKeys):
                key_resp_12.keys = _key_resp_12_allKeys[0].name  # just the first key pressed
                key_resp_12.rt = _key_resp_12_allKeys[0].rt
                # was this correct?
                if (key_resp_12.keys == str(key)) or (key_resp_12.keys == key):
                    key_resp_12.corr = 1
                else:
                    key_resp_12.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Trial4pComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Trial4p"-------
    for thisComponent in Trial4pComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial4.addData('good.started', good.tStartRefresh)
    Pract_Trial4.addData('good.stopped', good.tStopRefresh)
    Pract_Trial4.addData('ExNeg.started', ExNeg.tStartRefresh)
    Pract_Trial4.addData('ExNeg.stopped', ExNeg.tStopRefresh)
    Pract_Trial4.addData('text_SC_IAT.started', text_SC_IAT.tStartRefresh)
    Pract_Trial4.addData('text_SC_IAT.stopped', text_SC_IAT.tStopRefresh)
    # check responses
    if key_resp_12.keys in ['', [], None]:  # No response was made
        key_resp_12.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_12.corr = 1;  # correct non-response
        else:
           key_resp_12.corr = 0;  # failed to respond (incorrectly)
    # store data for Pract_Trial4 (TrialHandler)
    Pract_Trial4.addData('key_resp_12.keys',key_resp_12.keys)
    Pract_Trial4.addData('key_resp_12.corr', key_resp_12.corr)
    if key_resp_12.keys != None:  # we had a response
        Pract_Trial4.addData('key_resp_12.rt', key_resp_12.rt)
    Pract_Trial4.addData('key_resp_12.started', key_resp_12.tStartRefresh)
    Pract_Trial4.addData('key_resp_12.stopped', key_resp_12.tStopRefresh)
    
    # ------Prepare to start Routine "feedback4"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_12.corr:
        msg3 = "Correct"
    else:
        msg3 = "Wrong"
    text_16.setText(msg3)
    # keep track of which components have finished
    feedback4Components = [text_16]
    for thisComponent in feedback4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    feedback4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "feedback4"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = feedback4Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=feedback4Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_16* updates
        if text_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_16.frameNStart = frameN  # exact frame index
            text_16.tStart = t  # local t and not account for scr refresh
            text_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_16, 'tStartRefresh')  # time at next scr refresh
            text_16.setAutoDraw(True)
        if text_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_16.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_16.tStop = t  # not accounting for scr refresh
                text_16.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_16, 'tStopRefresh')  # time at next scr refresh
                text_16.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "feedback4"-------
    for thisComponent in feedback4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Pract_Trial4.addData('text_16.started', text_16.tStartRefresh)
    Pract_Trial4.addData('text_16.stopped', text_16.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'Pract_Trial4'


# ------Prepare to start Routine "Instructions4_T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_10.keys = []
key_resp_10.rt = []
_key_resp_10_allKeys = []
# keep track of which components have finished
Instructions4_TComponents = [text_6, textbox5_2, key_resp_10]
for thisComponent in Instructions4_TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions4_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions4_T"-------
while continueRoutine:
    # get current time
    t = Instructions4_TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions4_TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_6* updates
    if text_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_6.frameNStart = frameN  # exact frame index
        text_6.tStart = t  # local t and not account for scr refresh
        text_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_6, 'tStartRefresh')  # time at next scr refresh
        text_6.setAutoDraw(True)
    
    # *textbox5_2* updates
    if textbox5_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        textbox5_2.frameNStart = frameN  # exact frame index
        textbox5_2.tStart = t  # local t and not account for scr refresh
        textbox5_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(textbox5_2, 'tStartRefresh')  # time at next scr refresh
        textbox5_2.setAutoDraw(True)
    
    # *key_resp_10* updates
    waitOnFlip = False
    if key_resp_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_10.frameNStart = frameN  # exact frame index
        key_resp_10.tStart = t  # local t and not account for scr refresh
        key_resp_10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_10, 'tStartRefresh')  # time at next scr refresh
        key_resp_10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_10.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_10.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_10_allKeys.extend(theseKeys)
        if len(_key_resp_10_allKeys):
            key_resp_10.keys = _key_resp_10_allKeys[-1].name  # just the last key pressed
            key_resp_10.rt = _key_resp_10_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions4_TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions4_T"-------
for thisComponent in Instructions4_TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_6.started', text_6.tStartRefresh)
thisExp.addData('text_6.stopped', text_6.tStopRefresh)
thisExp.addData('textbox5_2.started', textbox5_2.tStartRefresh)
thisExp.addData('textbox5_2.stopped', textbox5_2.tStopRefresh)
# check responses
if key_resp_10.keys in ['', [], None]:  # No response was made
    key_resp_10.keys = None
thisExp.addData('key_resp_10.keys',key_resp_10.keys)
if key_resp_10.keys != None:  # we had a response
    thisExp.addData('key_resp_10.rt', key_resp_10.rt)
thisExp.addData('key_resp_10.started', key_resp_10.tStartRefresh)
thisExp.addData('key_resp_10.stopped', key_resp_10.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions4_T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Study_Trial4 = data.TrialHandler(nReps=2.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Block4.xlsx'),
    seed=None, name='Study_Trial4')
thisExp.addLoop(Study_Trial4)  # add the loop to the experiment
thisStudy_Trial4 = Study_Trial4.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial4.rgb)
if thisStudy_Trial4 != None:
    for paramName in thisStudy_Trial4:
        exec('{} = thisStudy_Trial4[paramName]'.format(paramName))

for thisStudy_Trial4 in Study_Trial4:
    currentLoop = Study_Trial4
    # abbreviate parameter names if possible (e.g. rgb = thisStudy_Trial4.rgb)
    if thisStudy_Trial4 != None:
        for paramName in thisStudy_Trial4:
            exec('{} = thisStudy_Trial4[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "trial4t"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    SC_IAT.setText(Stimulus)
    key_resp_16.keys = []
    key_resp_16.rt = []
    _key_resp_16_allKeys = []
    myCount7 = myCount7 + 1
    if myCount7 == 72:
        Study_Trial4.finished = True
    # keep track of which components have finished
    trial4tComponents = [txt_good1, txt_ExNeg, SC_IAT, key_resp_16]
    for thisComponent in trial4tComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    trial4tClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "trial4t"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = trial4tClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=trial4tClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *txt_good1* updates
        if txt_good1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            txt_good1.frameNStart = frameN  # exact frame index
            txt_good1.tStart = t  # local t and not account for scr refresh
            txt_good1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_good1, 'tStartRefresh')  # time at next scr refresh
            txt_good1.setAutoDraw(True)
        if txt_good1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_good1.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                txt_good1.tStop = t  # not accounting for scr refresh
                txt_good1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_good1, 'tStopRefresh')  # time at next scr refresh
                txt_good1.setAutoDraw(False)
        
        # *txt_ExNeg* updates
        if txt_ExNeg.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            txt_ExNeg.frameNStart = frameN  # exact frame index
            txt_ExNeg.tStart = t  # local t and not account for scr refresh
            txt_ExNeg.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(txt_ExNeg, 'tStartRefresh')  # time at next scr refresh
            txt_ExNeg.setAutoDraw(True)
        if txt_ExNeg.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > txt_ExNeg.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                txt_ExNeg.tStop = t  # not accounting for scr refresh
                txt_ExNeg.frameNStop = frameN  # exact frame index
                win.timeOnFlip(txt_ExNeg, 'tStopRefresh')  # time at next scr refresh
                txt_ExNeg.setAutoDraw(False)
        
        # *SC_IAT* updates
        if SC_IAT.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            SC_IAT.frameNStart = frameN  # exact frame index
            SC_IAT.tStart = t  # local t and not account for scr refresh
            SC_IAT.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(SC_IAT, 'tStartRefresh')  # time at next scr refresh
            SC_IAT.setAutoDraw(True)
        if SC_IAT.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > SC_IAT.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                SC_IAT.tStop = t  # not accounting for scr refresh
                SC_IAT.frameNStop = frameN  # exact frame index
                win.timeOnFlip(SC_IAT, 'tStopRefresh')  # time at next scr refresh
                SC_IAT.setAutoDraw(False)
        
        # *key_resp_16* updates
        waitOnFlip = False
        if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_16.frameNStart = frameN  # exact frame index
            key_resp_16.tStart = t  # local t and not account for scr refresh
            key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
            key_resp_16.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_16.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_16.tStop = t  # not accounting for scr refresh
                key_resp_16.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_16, 'tStopRefresh')  # time at next scr refresh
                key_resp_16.status = FINISHED
        if key_resp_16.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_16.getKeys(keyList=['m', 'z'], waitRelease=False)
            _key_resp_16_allKeys.extend(theseKeys)
            if len(_key_resp_16_allKeys):
                key_resp_16.keys = _key_resp_16_allKeys[0].name  # just the first key pressed
                key_resp_16.rt = _key_resp_16_allKeys[0].rt
                # was this correct?
                if (key_resp_16.keys == str(key)) or (key_resp_16.keys == key):
                    key_resp_16.corr = 1
                else:
                    key_resp_16.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in trial4tComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "trial4t"-------
    for thisComponent in trial4tComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Study_Trial4.addData('txt_good1.started', txt_good1.tStartRefresh)
    Study_Trial4.addData('txt_good1.stopped', txt_good1.tStopRefresh)
    Study_Trial4.addData('txt_ExNeg.started', txt_ExNeg.tStartRefresh)
    Study_Trial4.addData('txt_ExNeg.stopped', txt_ExNeg.tStopRefresh)
    Study_Trial4.addData('SC_IAT.started', SC_IAT.tStartRefresh)
    Study_Trial4.addData('SC_IAT.stopped', SC_IAT.tStopRefresh)
    # check responses
    if key_resp_16.keys in ['', [], None]:  # No response was made
        key_resp_16.keys = None
        # was no response the correct answer?!
        if str(key).lower() == 'none':
           key_resp_16.corr = 1;  # correct non-response
        else:
           key_resp_16.corr = 0;  # failed to respond (incorrectly)
    # store data for Study_Trial4 (TrialHandler)
    Study_Trial4.addData('key_resp_16.keys',key_resp_16.keys)
    Study_Trial4.addData('key_resp_16.corr', key_resp_16.corr)
    if key_resp_16.keys != None:  # we had a response
        Study_Trial4.addData('key_resp_16.rt', key_resp_16.rt)
    Study_Trial4.addData('key_resp_16.started', key_resp_16.tStartRefresh)
    Study_Trial4.addData('key_resp_16.stopped', key_resp_16.tStopRefresh)
    thisExp.nextEntry()
    
# completed 2.0 repeats of 'Study_Trial4'


# ------Prepare to start Routine "STROOP"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_18.keys = []
key_resp_18.rt = []
_key_resp_18_allKeys = []
# keep track of which components have finished
STROOPComponents = [text_8, key_resp_18]
for thisComponent in STROOPComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
STROOPClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "STROOP"-------
while continueRoutine:
    # get current time
    t = STROOPClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=STROOPClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_8* updates
    if text_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_8.frameNStart = frameN  # exact frame index
        text_8.tStart = t  # local t and not account for scr refresh
        text_8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_8, 'tStartRefresh')  # time at next scr refresh
        text_8.setAutoDraw(True)
    
    # *key_resp_18* updates
    waitOnFlip = False
    if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_18.frameNStart = frameN  # exact frame index
        key_resp_18.tStart = t  # local t and not account for scr refresh
        key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
        key_resp_18.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_18.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_18.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_18_allKeys.extend(theseKeys)
        if len(_key_resp_18_allKeys):
            key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
            key_resp_18.rt = _key_resp_18_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in STROOPComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "STROOP"-------
for thisComponent in STROOPComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_8.started', text_8.tStartRefresh)
thisExp.addData('text_8.stopped', text_8.tStopRefresh)
# check responses
if key_resp_18.keys in ['', [], None]:  # No response was made
    key_resp_18.keys = None
thisExp.addData('key_resp_18.keys',key_resp_18.keys)
if key_resp_18.keys != None:  # we had a response
    thisExp.addData('key_resp_18.rt', key_resp_18.rt)
thisExp.addData('key_resp_18.started', key_resp_18.tStartRefresh)
thisExp.addData('key_resp_18.stopped', key_resp_18.tStopRefresh)
thisExp.nextEntry()
# the Routine "STROOP" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Stroop_Instr"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_19.keys = []
key_resp_19.rt = []
_key_resp_19_allKeys = []
# keep track of which components have finished
Stroop_InstrComponents = [text_9, key_resp_19]
for thisComponent in Stroop_InstrComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Stroop_InstrClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Stroop_Instr"-------
while continueRoutine:
    # get current time
    t = Stroop_InstrClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Stroop_InstrClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_9* updates
    if text_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_9.frameNStart = frameN  # exact frame index
        text_9.tStart = t  # local t and not account for scr refresh
        text_9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_9, 'tStartRefresh')  # time at next scr refresh
        text_9.setAutoDraw(True)
    
    # *key_resp_19* updates
    waitOnFlip = False
    if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_19.frameNStart = frameN  # exact frame index
        key_resp_19.tStart = t  # local t and not account for scr refresh
        key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
        key_resp_19.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_19.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_19.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_19_allKeys.extend(theseKeys)
        if len(_key_resp_19_allKeys):
            key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
            key_resp_19.rt = _key_resp_19_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Stroop_InstrComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Stroop_Instr"-------
for thisComponent in Stroop_InstrComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_9.started', text_9.tStartRefresh)
thisExp.addData('text_9.stopped', text_9.tStopRefresh)
# check responses
if key_resp_19.keys in ['', [], None]:  # No response was made
    key_resp_19.keys = None
thisExp.addData('key_resp_19.keys',key_resp_19.keys)
if key_resp_19.keys != None:  # we had a response
    thisExp.addData('key_resp_19.rt', key_resp_19.rt)
thisExp.addData('key_resp_19.started', key_resp_19.tStartRefresh)
thisExp.addData('key_resp_19.stopped', key_resp_19.tStopRefresh)
thisExp.nextEntry()
# the Routine "Stroop_Instr" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
pract_stroop1 = data.TrialHandler(nReps=2.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('pract_stroop.xlsx'),
    seed=None, name='pract_stroop1')
thisExp.addLoop(pract_stroop1)  # add the loop to the experiment
thisPract_stroop1 = pract_stroop1.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPract_stroop1.rgb)
if thisPract_stroop1 != None:
    for paramName in thisPract_stroop1:
        exec('{} = thisPract_stroop1[paramName]'.format(paramName))

for thisPract_stroop1 in pract_stroop1:
    currentLoop = pract_stroop1
    # abbreviate parameter names if possible (e.g. rgb = thisPract_stroop1.rgb)
    if thisPract_stroop1 != None:
        for paramName in thisPract_stroop1:
            exec('{} = thisPract_stroop1[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "pract_stroop"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    text_10.setColor(color, colorSpace='rgb')
    text_10.setText(word)
    key_resp_20.keys = []
    key_resp_20.rt = []
    _key_resp_20_allKeys = []
    # keep track of which components have finished
    pract_stroopComponents = [b, n, m, text_10, key_resp_20]
    for thisComponent in pract_stroopComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    pract_stroopClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "pract_stroop"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = pract_stroopClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=pract_stroopClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *b* updates
        if b.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            b.frameNStart = frameN  # exact frame index
            b.tStart = t  # local t and not account for scr refresh
            b.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(b, 'tStartRefresh')  # time at next scr refresh
            b.setAutoDraw(True)
        if b.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > b.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                b.tStop = t  # not accounting for scr refresh
                b.frameNStop = frameN  # exact frame index
                win.timeOnFlip(b, 'tStopRefresh')  # time at next scr refresh
                b.setAutoDraw(False)
        
        # *n* updates
        if n.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            n.frameNStart = frameN  # exact frame index
            n.tStart = t  # local t and not account for scr refresh
            n.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(n, 'tStartRefresh')  # time at next scr refresh
            n.setAutoDraw(True)
        if n.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > n.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                n.tStop = t  # not accounting for scr refresh
                n.frameNStop = frameN  # exact frame index
                win.timeOnFlip(n, 'tStopRefresh')  # time at next scr refresh
                n.setAutoDraw(False)
        
        # *m* updates
        if m.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            m.frameNStart = frameN  # exact frame index
            m.tStart = t  # local t and not account for scr refresh
            m.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(m, 'tStartRefresh')  # time at next scr refresh
            m.setAutoDraw(True)
        if m.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > m.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                m.tStop = t  # not accounting for scr refresh
                m.frameNStop = frameN  # exact frame index
                win.timeOnFlip(m, 'tStopRefresh')  # time at next scr refresh
                m.setAutoDraw(False)
        
        # *text_10* updates
        if text_10.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            text_10.frameNStart = frameN  # exact frame index
            text_10.tStart = t  # local t and not account for scr refresh
            text_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_10, 'tStartRefresh')  # time at next scr refresh
            text_10.setAutoDraw(True)
        if text_10.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_10.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                text_10.tStop = t  # not accounting for scr refresh
                text_10.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_10, 'tStopRefresh')  # time at next scr refresh
                text_10.setAutoDraw(False)
        
        # *key_resp_20* updates
        waitOnFlip = False
        if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_20.frameNStart = frameN  # exact frame index
            key_resp_20.tStart = t  # local t and not account for scr refresh
            key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
            key_resp_20.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_20.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_20.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_20.tStop = t  # not accounting for scr refresh
                key_resp_20.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_20, 'tStopRefresh')  # time at next scr refresh
                key_resp_20.status = FINISHED
        if key_resp_20.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_20.getKeys(keyList=['b', 'n', 'm'], waitRelease=False)
            _key_resp_20_allKeys.extend(theseKeys)
            if len(_key_resp_20_allKeys):
                key_resp_20.keys = _key_resp_20_allKeys[0].name  # just the first key pressed
                key_resp_20.rt = _key_resp_20_allKeys[0].rt
                # was this correct?
                if (key_resp_20.keys == str(corrAns)) or (key_resp_20.keys == corrAns):
                    key_resp_20.corr = 1
                else:
                    key_resp_20.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in pract_stroopComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "pract_stroop"-------
    for thisComponent in pract_stroopComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    pract_stroop1.addData('b.started', b.tStartRefresh)
    pract_stroop1.addData('b.stopped', b.tStopRefresh)
    pract_stroop1.addData('n.started', n.tStartRefresh)
    pract_stroop1.addData('n.stopped', n.tStopRefresh)
    pract_stroop1.addData('m.started', m.tStartRefresh)
    pract_stroop1.addData('m.stopped', m.tStopRefresh)
    pract_stroop1.addData('text_10.started', text_10.tStartRefresh)
    pract_stroop1.addData('text_10.stopped', text_10.tStopRefresh)
    # check responses
    if key_resp_20.keys in ['', [], None]:  # No response was made
        key_resp_20.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_20.corr = 1;  # correct non-response
        else:
           key_resp_20.corr = 0;  # failed to respond (incorrectly)
    # store data for pract_stroop1 (TrialHandler)
    pract_stroop1.addData('key_resp_20.keys',key_resp_20.keys)
    pract_stroop1.addData('key_resp_20.corr', key_resp_20.corr)
    if key_resp_20.keys != None:  # we had a response
        pract_stroop1.addData('key_resp_20.rt', key_resp_20.rt)
    pract_stroop1.addData('key_resp_20.started', key_resp_20.tStartRefresh)
    pract_stroop1.addData('key_resp_20.stopped', key_resp_20.tStopRefresh)
    
    # ------Prepare to start Routine "feedbackS"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_20.corr:
        msg5 = "Correct"
    else:
        msg5 = "Wrong"
    text_17.setText(msg5)
    # keep track of which components have finished
    feedbackSComponents = [text_17]
    for thisComponent in feedbackSComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    feedbackSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "feedbackS"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = feedbackSClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=feedbackSClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_17* updates
        if text_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_17.frameNStart = frameN  # exact frame index
            text_17.tStart = t  # local t and not account for scr refresh
            text_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_17, 'tStartRefresh')  # time at next scr refresh
            text_17.setAutoDraw(True)
        if text_17.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_17.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_17.tStop = t  # not accounting for scr refresh
                text_17.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_17, 'tStopRefresh')  # time at next scr refresh
                text_17.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedbackSComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "feedbackS"-------
    for thisComponent in feedbackSComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    pract_stroop1.addData('text_17.started', text_17.tStartRefresh)
    pract_stroop1.addData('text_17.stopped', text_17.tStopRefresh)
    thisExp.nextEntry()
    
# completed 2.0 repeats of 'pract_stroop1'


# ------Prepare to start Routine "Stroop_Test"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_21.keys = []
key_resp_21.rt = []
_key_resp_21_allKeys = []
# keep track of which components have finished
Stroop_TestComponents = [text_11, key_resp_21]
for thisComponent in Stroop_TestComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Stroop_TestClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Stroop_Test"-------
while continueRoutine:
    # get current time
    t = Stroop_TestClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Stroop_TestClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_11* updates
    if text_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_11.frameNStart = frameN  # exact frame index
        text_11.tStart = t  # local t and not account for scr refresh
        text_11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_11, 'tStartRefresh')  # time at next scr refresh
        text_11.setAutoDraw(True)
    
    # *key_resp_21* updates
    waitOnFlip = False
    if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_21.frameNStart = frameN  # exact frame index
        key_resp_21.tStart = t  # local t and not account for scr refresh
        key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
        key_resp_21.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_21.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_21.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_21_allKeys.extend(theseKeys)
        if len(_key_resp_21_allKeys):
            key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
            key_resp_21.rt = _key_resp_21_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Stroop_TestComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Stroop_Test"-------
for thisComponent in Stroop_TestComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_11.started', text_11.tStartRefresh)
thisExp.addData('text_11.stopped', text_11.tStopRefresh)
# check responses
if key_resp_21.keys in ['', [], None]:  # No response was made
    key_resp_21.keys = None
thisExp.addData('key_resp_21.keys',key_resp_21.keys)
if key_resp_21.keys != None:  # we had a response
    thisExp.addData('key_resp_21.rt', key_resp_21.rt)
thisExp.addData('key_resp_21.started', key_resp_21.tStartRefresh)
thisExp.addData('key_resp_21.stopped', key_resp_21.tStopRefresh)
thisExp.nextEntry()
# the Routine "Stroop_Test" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
test_stroop1 = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('trial_stroop.xlsx'),
    seed=None, name='test_stroop1')
thisExp.addLoop(test_stroop1)  # add the loop to the experiment
thisTest_stroop1 = test_stroop1.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTest_stroop1.rgb)
if thisTest_stroop1 != None:
    for paramName in thisTest_stroop1:
        exec('{} = thisTest_stroop1[paramName]'.format(paramName))

for thisTest_stroop1 in test_stroop1:
    currentLoop = test_stroop1
    # abbreviate parameter names if possible (e.g. rgb = thisTest_stroop1.rgb)
    if thisTest_stroop1 != None:
        for paramName in thisTest_stroop1:
            exec('{} = thisTest_stroop1[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "trial_stroop"-------
    continueRoutine = True
    routineTimer.add(4.300000)
    # update component parameters for each repeat
    text_12.setColor(color, colorSpace='rgb')
    text_12.setText(word)
    key_resp_22.keys = []
    key_resp_22.rt = []
    _key_resp_22_allKeys = []
    # keep track of which components have finished
    trial_stroopComponents = [b1, n1, m1, text_12, key_resp_22]
    for thisComponent in trial_stroopComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    trial_stroopClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "trial_stroop"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = trial_stroopClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=trial_stroopClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *b1* updates
        if b1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            b1.frameNStart = frameN  # exact frame index
            b1.tStart = t  # local t and not account for scr refresh
            b1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(b1, 'tStartRefresh')  # time at next scr refresh
            b1.setAutoDraw(True)
        if b1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > b1.tStartRefresh + 4.3-frameTolerance:
                # keep track of stop time/frame for later
                b1.tStop = t  # not accounting for scr refresh
                b1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(b1, 'tStopRefresh')  # time at next scr refresh
                b1.setAutoDraw(False)
        
        # *n1* updates
        if n1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            n1.frameNStart = frameN  # exact frame index
            n1.tStart = t  # local t and not account for scr refresh
            n1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(n1, 'tStartRefresh')  # time at next scr refresh
            n1.setAutoDraw(True)
        if n1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > n1.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                n1.tStop = t  # not accounting for scr refresh
                n1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(n1, 'tStopRefresh')  # time at next scr refresh
                n1.setAutoDraw(False)
        
        # *m1* updates
        if m1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            m1.frameNStart = frameN  # exact frame index
            m1.tStart = t  # local t and not account for scr refresh
            m1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(m1, 'tStartRefresh')  # time at next scr refresh
            m1.setAutoDraw(True)
        if m1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > m1.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                m1.tStop = t  # not accounting for scr refresh
                m1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(m1, 'tStopRefresh')  # time at next scr refresh
                m1.setAutoDraw(False)
        
        # *text_12* updates
        if text_12.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            text_12.frameNStart = frameN  # exact frame index
            text_12.tStart = t  # local t and not account for scr refresh
            text_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_12, 'tStartRefresh')  # time at next scr refresh
            text_12.setAutoDraw(True)
        if text_12.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_12.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                text_12.tStop = t  # not accounting for scr refresh
                text_12.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_12, 'tStopRefresh')  # time at next scr refresh
                text_12.setAutoDraw(False)
        
        # *key_resp_22* updates
        waitOnFlip = False
        if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.3-frameTolerance:
            # keep track of start time/frame for later
            key_resp_22.frameNStart = frameN  # exact frame index
            key_resp_22.tStart = t  # local t and not account for scr refresh
            key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
            key_resp_22.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_22.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_22.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_22.tStop = t  # not accounting for scr refresh
                key_resp_22.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_22, 'tStopRefresh')  # time at next scr refresh
                key_resp_22.status = FINISHED
        if key_resp_22.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_22.getKeys(keyList=['b', 'n', 'm'], waitRelease=False)
            _key_resp_22_allKeys.extend(theseKeys)
            if len(_key_resp_22_allKeys):
                key_resp_22.keys = _key_resp_22_allKeys[0].name  # just the first key pressed
                key_resp_22.rt = _key_resp_22_allKeys[0].rt
                # was this correct?
                if (key_resp_22.keys == str(corrAns)) or (key_resp_22.keys == corrAns):
                    key_resp_22.corr = 1
                else:
                    key_resp_22.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in trial_stroopComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "trial_stroop"-------
    for thisComponent in trial_stroopComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    test_stroop1.addData('b1.started', b1.tStartRefresh)
    test_stroop1.addData('b1.stopped', b1.tStopRefresh)
    test_stroop1.addData('n1.started', n1.tStartRefresh)
    test_stroop1.addData('n1.stopped', n1.tStopRefresh)
    test_stroop1.addData('m1.started', m1.tStartRefresh)
    test_stroop1.addData('m1.stopped', m1.tStopRefresh)
    test_stroop1.addData('text_12.started', text_12.tStartRefresh)
    test_stroop1.addData('text_12.stopped', text_12.tStopRefresh)
    # check responses
    if key_resp_22.keys in ['', [], None]:  # No response was made
        key_resp_22.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_22.corr = 1;  # correct non-response
        else:
           key_resp_22.corr = 0;  # failed to respond (incorrectly)
    # store data for test_stroop1 (TrialHandler)
    test_stroop1.addData('key_resp_22.keys',key_resp_22.keys)
    test_stroop1.addData('key_resp_22.corr', key_resp_22.corr)
    if key_resp_22.keys != None:  # we had a response
        test_stroop1.addData('key_resp_22.rt', key_resp_22.rt)
    test_stroop1.addData('key_resp_22.started', key_resp_22.tStartRefresh)
    test_stroop1.addData('key_resp_22.stopped', key_resp_22.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'test_stroop1'


# ------Prepare to start Routine "N_Back"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_26.keys = []
key_resp_26.rt = []
_key_resp_26_allKeys = []
# keep track of which components have finished
N_BackComponents = [text_20, key_resp_26]
for thisComponent in N_BackComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
N_BackClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "N_Back"-------
while continueRoutine:
    # get current time
    t = N_BackClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=N_BackClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_20* updates
    if text_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_20.frameNStart = frameN  # exact frame index
        text_20.tStart = t  # local t and not account for scr refresh
        text_20.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_20, 'tStartRefresh')  # time at next scr refresh
        text_20.setAutoDraw(True)
    
    # *key_resp_26* updates
    waitOnFlip = False
    if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_26.frameNStart = frameN  # exact frame index
        key_resp_26.tStart = t  # local t and not account for scr refresh
        key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
        key_resp_26.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_26.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_26.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_26_allKeys.extend(theseKeys)
        if len(_key_resp_26_allKeys):
            key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
            key_resp_26.rt = _key_resp_26_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in N_BackComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "N_Back"-------
for thisComponent in N_BackComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_20.started', text_20.tStartRefresh)
thisExp.addData('text_20.stopped', text_20.tStopRefresh)
# check responses
if key_resp_26.keys in ['', [], None]:  # No response was made
    key_resp_26.keys = None
thisExp.addData('key_resp_26.keys',key_resp_26.keys)
if key_resp_26.keys != None:  # we had a response
    thisExp.addData('key_resp_26.rt', key_resp_26.rt)
thisExp.addData('key_resp_26.started', key_resp_26.tStartRefresh)
thisExp.addData('key_resp_26.stopped', key_resp_26.tStopRefresh)
thisExp.nextEntry()
# the Routine "N_Back" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Instructions_Nback1Pract"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_27.keys = []
key_resp_27.rt = []
_key_resp_27_allKeys = []
# keep track of which components have finished
Instructions_Nback1PractComponents = [text_22, key_resp_27]
for thisComponent in Instructions_Nback1PractComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions_Nback1PractClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions_Nback1Pract"-------
while continueRoutine:
    # get current time
    t = Instructions_Nback1PractClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions_Nback1PractClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_22* updates
    if text_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_22.frameNStart = frameN  # exact frame index
        text_22.tStart = t  # local t and not account for scr refresh
        text_22.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_22, 'tStartRefresh')  # time at next scr refresh
        text_22.setAutoDraw(True)
    
    # *key_resp_27* updates
    waitOnFlip = False
    if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_27.frameNStart = frameN  # exact frame index
        key_resp_27.tStart = t  # local t and not account for scr refresh
        key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
        key_resp_27.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_27.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_27.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_27_allKeys.extend(theseKeys)
        if len(_key_resp_27_allKeys):
            key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
            key_resp_27.rt = _key_resp_27_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions_Nback1PractComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions_Nback1Pract"-------
for thisComponent in Instructions_Nback1PractComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_22.started', text_22.tStartRefresh)
thisExp.addData('text_22.stopped', text_22.tStopRefresh)
# check responses
if key_resp_27.keys in ['', [], None]:  # No response was made
    key_resp_27.keys = None
thisExp.addData('key_resp_27.keys',key_resp_27.keys)
if key_resp_27.keys != None:  # we had a response
    thisExp.addData('key_resp_27.rt', key_resp_27.rt)
thisExp.addData('key_resp_27.started', key_resp_27.tStartRefresh)
thisExp.addData('key_resp_27.stopped', key_resp_27.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions_Nback1Pract" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
pract_nback1 = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('nback_1p.xlsx'),
    seed=None, name='pract_nback1')
thisExp.addLoop(pract_nback1)  # add the loop to the experiment
thisPract_nback1 = pract_nback1.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPract_nback1.rgb)
if thisPract_nback1 != None:
    for paramName in thisPract_nback1:
        exec('{} = thisPract_nback1[paramName]'.format(paramName))

for thisPract_nback1 in pract_nback1:
    currentLoop = pract_nback1
    # abbreviate parameter names if possible (e.g. rgb = thisPract_nback1.rgb)
    if thisPract_nback1 != None:
        for paramName in thisPract_nback1:
            exec('{} = thisPract_nback1[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "pract_nback"-------
    continueRoutine = True
    routineTimer.add(2.000000)
    # update component parameters for each repeat
    pract_nbackstim.setText(letter)
    key_resp_nbackP1.keys = []
    key_resp_nbackP1.rt = []
    _key_resp_nbackP1_allKeys = []
    # keep track of which components have finished
    pract_nbackComponents = [pract_nbackstim, key_resp_nbackP1]
    for thisComponent in pract_nbackComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    pract_nbackClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "pract_nback"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = pract_nbackClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=pract_nbackClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *pract_nbackstim* updates
        if pract_nbackstim.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            pract_nbackstim.frameNStart = frameN  # exact frame index
            pract_nbackstim.tStart = t  # local t and not account for scr refresh
            pract_nbackstim.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(pract_nbackstim, 'tStartRefresh')  # time at next scr refresh
            pract_nbackstim.setAutoDraw(True)
        if pract_nbackstim.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > pract_nbackstim.tStartRefresh + 0.5-frameTolerance:
                # keep track of stop time/frame for later
                pract_nbackstim.tStop = t  # not accounting for scr refresh
                pract_nbackstim.frameNStop = frameN  # exact frame index
                win.timeOnFlip(pract_nbackstim, 'tStopRefresh')  # time at next scr refresh
                pract_nbackstim.setAutoDraw(False)
        
        # *key_resp_nbackP1* updates
        waitOnFlip = False
        if key_resp_nbackP1.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_nbackP1.frameNStart = frameN  # exact frame index
            key_resp_nbackP1.tStart = t  # local t and not account for scr refresh
            key_resp_nbackP1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_nbackP1, 'tStartRefresh')  # time at next scr refresh
            key_resp_nbackP1.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_nbackP1.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_nbackP1.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_nbackP1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_nbackP1.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_nbackP1.tStop = t  # not accounting for scr refresh
                key_resp_nbackP1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_nbackP1, 'tStopRefresh')  # time at next scr refresh
                key_resp_nbackP1.status = FINISHED
        if key_resp_nbackP1.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_nbackP1.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_nbackP1_allKeys.extend(theseKeys)
            if len(_key_resp_nbackP1_allKeys):
                key_resp_nbackP1.keys = _key_resp_nbackP1_allKeys[0].name  # just the first key pressed
                key_resp_nbackP1.rt = _key_resp_nbackP1_allKeys[0].rt
                # was this correct?
                if (key_resp_nbackP1.keys == str(corrAns)) or (key_resp_nbackP1.keys == corrAns):
                    key_resp_nbackP1.corr = 1
                else:
                    key_resp_nbackP1.corr = 0
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in pract_nbackComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "pract_nback"-------
    for thisComponent in pract_nbackComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    pract_nback1.addData('pract_nbackstim.started', pract_nbackstim.tStartRefresh)
    pract_nback1.addData('pract_nbackstim.stopped', pract_nbackstim.tStopRefresh)
    # check responses
    if key_resp_nbackP1.keys in ['', [], None]:  # No response was made
        key_resp_nbackP1.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_nbackP1.corr = 1;  # correct non-response
        else:
           key_resp_nbackP1.corr = 0;  # failed to respond (incorrectly)
    # store data for pract_nback1 (TrialHandler)
    pract_nback1.addData('key_resp_nbackP1.keys',key_resp_nbackP1.keys)
    pract_nback1.addData('key_resp_nbackP1.corr', key_resp_nbackP1.corr)
    if key_resp_nbackP1.keys != None:  # we had a response
        pract_nback1.addData('key_resp_nbackP1.rt', key_resp_nbackP1.rt)
    pract_nback1.addData('key_resp_nbackP1.started', key_resp_nbackP1.tStartRefresh)
    pract_nback1.addData('key_resp_nbackP1.stopped', key_resp_nbackP1.tStopRefresh)
    
    # ------Prepare to start Routine "feedback_Pnback1"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_nbackP1.corr:
        msg6 = "Correct"
    else:
        msg6 = "Wrong"
    text_21.setText(msg6)
    # keep track of which components have finished
    feedback_Pnback1Components = [text_21]
    for thisComponent in feedback_Pnback1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    feedback_Pnback1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "feedback_Pnback1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = feedback_Pnback1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=feedback_Pnback1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_21* updates
        if text_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_21.frameNStart = frameN  # exact frame index
            text_21.tStart = t  # local t and not account for scr refresh
            text_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_21, 'tStartRefresh')  # time at next scr refresh
            text_21.setAutoDraw(True)
        if text_21.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_21.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_21.tStop = t  # not accounting for scr refresh
                text_21.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_21, 'tStopRefresh')  # time at next scr refresh
                text_21.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback_Pnback1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "feedback_Pnback1"-------
    for thisComponent in feedback_Pnback1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    pract_nback1.addData('text_21.started', text_21.tStartRefresh)
    pract_nback1.addData('text_21.stopped', text_21.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'pract_nback1'


# ------Prepare to start Routine "Instructions_Nback1T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_28.keys = []
key_resp_28.rt = []
_key_resp_28_allKeys = []
# keep track of which components have finished
Instructions_Nback1TComponents = [text_23, key_resp_28]
for thisComponent in Instructions_Nback1TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions_Nback1TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions_Nback1T"-------
while continueRoutine:
    # get current time
    t = Instructions_Nback1TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions_Nback1TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_23* updates
    if text_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_23.frameNStart = frameN  # exact frame index
        text_23.tStart = t  # local t and not account for scr refresh
        text_23.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_23, 'tStartRefresh')  # time at next scr refresh
        text_23.setAutoDraw(True)
    
    # *key_resp_28* updates
    waitOnFlip = False
    if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_28.frameNStart = frameN  # exact frame index
        key_resp_28.tStart = t  # local t and not account for scr refresh
        key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
        key_resp_28.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_28.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_28.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_28_allKeys.extend(theseKeys)
        if len(_key_resp_28_allKeys):
            key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
            key_resp_28.rt = _key_resp_28_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions_Nback1TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions_Nback1T"-------
for thisComponent in Instructions_Nback1TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_23.started', text_23.tStartRefresh)
thisExp.addData('text_23.stopped', text_23.tStopRefresh)
# check responses
if key_resp_28.keys in ['', [], None]:  # No response was made
    key_resp_28.keys = None
thisExp.addData('key_resp_28.keys',key_resp_28.keys)
if key_resp_28.keys != None:  # we had a response
    thisExp.addData('key_resp_28.rt', key_resp_28.rt)
thisExp.addData('key_resp_28.started', key_resp_28.tStartRefresh)
thisExp.addData('key_resp_28.stopped', key_resp_28.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions_Nback1T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
test_nback1 = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('nback_1.xlsx'),
    seed=None, name='test_nback1')
thisExp.addLoop(test_nback1)  # add the loop to the experiment
thisTest_nback1 = test_nback1.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTest_nback1.rgb)
if thisTest_nback1 != None:
    for paramName in thisTest_nback1:
        exec('{} = thisTest_nback1[paramName]'.format(paramName))

for thisTest_nback1 in test_nback1:
    currentLoop = test_nback1
    # abbreviate parameter names if possible (e.g. rgb = thisTest_nback1.rgb)
    if thisTest_nback1 != None:
        for paramName in thisTest_nback1:
            exec('{} = thisTest_nback1[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "nback1_trial"-------
    continueRoutine = True
    routineTimer.add(2.000000)
    # update component parameters for each repeat
    nback1_stim.setText(letter)
    key_resp_29.keys = []
    key_resp_29.rt = []
    _key_resp_29_allKeys = []
    # keep track of which components have finished
    nback1_trialComponents = [nback1_stim, key_resp_29]
    for thisComponent in nback1_trialComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    nback1_trialClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "nback1_trial"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = nback1_trialClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=nback1_trialClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *nback1_stim* updates
        if nback1_stim.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            nback1_stim.frameNStart = frameN  # exact frame index
            nback1_stim.tStart = t  # local t and not account for scr refresh
            nback1_stim.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(nback1_stim, 'tStartRefresh')  # time at next scr refresh
            nback1_stim.setAutoDraw(True)
        if nback1_stim.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > nback1_stim.tStartRefresh + 0.5-frameTolerance:
                # keep track of stop time/frame for later
                nback1_stim.tStop = t  # not accounting for scr refresh
                nback1_stim.frameNStop = frameN  # exact frame index
                win.timeOnFlip(nback1_stim, 'tStopRefresh')  # time at next scr refresh
                nback1_stim.setAutoDraw(False)
        
        # *key_resp_29* updates
        waitOnFlip = False
        if key_resp_29.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_29.frameNStart = frameN  # exact frame index
            key_resp_29.tStart = t  # local t and not account for scr refresh
            key_resp_29.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_29, 'tStartRefresh')  # time at next scr refresh
            key_resp_29.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_29.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_29.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_29.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_29.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_29.tStop = t  # not accounting for scr refresh
                key_resp_29.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_29, 'tStopRefresh')  # time at next scr refresh
                key_resp_29.status = FINISHED
        if key_resp_29.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_29.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_29_allKeys.extend(theseKeys)
            if len(_key_resp_29_allKeys):
                key_resp_29.keys = [key.name for key in _key_resp_29_allKeys]  # storing all keys
                key_resp_29.rt = [key.rt for key in _key_resp_29_allKeys]
                # was this correct?
                if (key_resp_29.keys == str(corrAns)) or (key_resp_29.keys == corrAns):
                    key_resp_29.corr = 1
                else:
                    key_resp_29.corr = 0
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in nback1_trialComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "nback1_trial"-------
    for thisComponent in nback1_trialComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    test_nback1.addData('nback1_stim.started', nback1_stim.tStartRefresh)
    test_nback1.addData('nback1_stim.stopped', nback1_stim.tStopRefresh)
    # check responses
    if key_resp_29.keys in ['', [], None]:  # No response was made
        key_resp_29.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_29.corr = 1;  # correct non-response
        else:
           key_resp_29.corr = 0;  # failed to respond (incorrectly)
    # store data for test_nback1 (TrialHandler)
    test_nback1.addData('key_resp_29.keys',key_resp_29.keys)
    test_nback1.addData('key_resp_29.corr', key_resp_29.corr)
    if key_resp_29.keys != None:  # we had a response
        test_nback1.addData('key_resp_29.rt', key_resp_29.rt)
    test_nback1.addData('key_resp_29.started', key_resp_29.tStartRefresh)
    test_nback1.addData('key_resp_29.stopped', key_resp_29.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'test_nback1'


# ------Prepare to start Routine "Instructions_Nback2Pract"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_30.keys = []
key_resp_30.rt = []
_key_resp_30_allKeys = []
# keep track of which components have finished
Instructions_Nback2PractComponents = [text_24, key_resp_30]
for thisComponent in Instructions_Nback2PractComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions_Nback2PractClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions_Nback2Pract"-------
while continueRoutine:
    # get current time
    t = Instructions_Nback2PractClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions_Nback2PractClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_24* updates
    if text_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_24.frameNStart = frameN  # exact frame index
        text_24.tStart = t  # local t and not account for scr refresh
        text_24.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_24, 'tStartRefresh')  # time at next scr refresh
        text_24.setAutoDraw(True)
    
    # *key_resp_30* updates
    waitOnFlip = False
    if key_resp_30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_30.frameNStart = frameN  # exact frame index
        key_resp_30.tStart = t  # local t and not account for scr refresh
        key_resp_30.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_30, 'tStartRefresh')  # time at next scr refresh
        key_resp_30.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_30.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_30.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_30.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_30.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_30_allKeys.extend(theseKeys)
        if len(_key_resp_30_allKeys):
            key_resp_30.keys = _key_resp_30_allKeys[-1].name  # just the last key pressed
            key_resp_30.rt = _key_resp_30_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions_Nback2PractComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions_Nback2Pract"-------
for thisComponent in Instructions_Nback2PractComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_24.started', text_24.tStartRefresh)
thisExp.addData('text_24.stopped', text_24.tStopRefresh)
# check responses
if key_resp_30.keys in ['', [], None]:  # No response was made
    key_resp_30.keys = None
thisExp.addData('key_resp_30.keys',key_resp_30.keys)
if key_resp_30.keys != None:  # we had a response
    thisExp.addData('key_resp_30.rt', key_resp_30.rt)
thisExp.addData('key_resp_30.started', key_resp_30.tStartRefresh)
thisExp.addData('key_resp_30.stopped', key_resp_30.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions_Nback2Pract" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
pract_nback2l = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('nback_2p.xlsx'),
    seed=None, name='pract_nback2l')
thisExp.addLoop(pract_nback2l)  # add the loop to the experiment
thisPract_nback2l = pract_nback2l.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPract_nback2l.rgb)
if thisPract_nback2l != None:
    for paramName in thisPract_nback2l:
        exec('{} = thisPract_nback2l[paramName]'.format(paramName))

for thisPract_nback2l in pract_nback2l:
    currentLoop = pract_nback2l
    # abbreviate parameter names if possible (e.g. rgb = thisPract_nback2l.rgb)
    if thisPract_nback2l != None:
        for paramName in thisPract_nback2l:
            exec('{} = thisPract_nback2l[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "pract_nback2"-------
    continueRoutine = True
    routineTimer.add(2.000000)
    # update component parameters for each repeat
    pract_nback2stim.setText(letter)
    key_resp_nbackP2.keys = []
    key_resp_nbackP2.rt = []
    _key_resp_nbackP2_allKeys = []
    # keep track of which components have finished
    pract_nback2Components = [pract_nback2stim, key_resp_nbackP2]
    for thisComponent in pract_nback2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    pract_nback2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "pract_nback2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = pract_nback2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=pract_nback2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *pract_nback2stim* updates
        if pract_nback2stim.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            pract_nback2stim.frameNStart = frameN  # exact frame index
            pract_nback2stim.tStart = t  # local t and not account for scr refresh
            pract_nback2stim.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(pract_nback2stim, 'tStartRefresh')  # time at next scr refresh
            pract_nback2stim.setAutoDraw(True)
        if pract_nback2stim.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > pract_nback2stim.tStartRefresh + 0.5-frameTolerance:
                # keep track of stop time/frame for later
                pract_nback2stim.tStop = t  # not accounting for scr refresh
                pract_nback2stim.frameNStop = frameN  # exact frame index
                win.timeOnFlip(pract_nback2stim, 'tStopRefresh')  # time at next scr refresh
                pract_nback2stim.setAutoDraw(False)
        
        # *key_resp_nbackP2* updates
        waitOnFlip = False
        if key_resp_nbackP2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_nbackP2.frameNStart = frameN  # exact frame index
            key_resp_nbackP2.tStart = t  # local t and not account for scr refresh
            key_resp_nbackP2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_nbackP2, 'tStartRefresh')  # time at next scr refresh
            key_resp_nbackP2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_nbackP2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_nbackP2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_nbackP2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_nbackP2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_nbackP2.tStop = t  # not accounting for scr refresh
                key_resp_nbackP2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_nbackP2, 'tStopRefresh')  # time at next scr refresh
                key_resp_nbackP2.status = FINISHED
        if key_resp_nbackP2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_nbackP2.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_nbackP2_allKeys.extend(theseKeys)
            if len(_key_resp_nbackP2_allKeys):
                key_resp_nbackP2.keys = _key_resp_nbackP2_allKeys[0].name  # just the first key pressed
                key_resp_nbackP2.rt = _key_resp_nbackP2_allKeys[0].rt
                # was this correct?
                if (key_resp_nbackP2.keys == str(corrAns)) or (key_resp_nbackP2.keys == corrAns):
                    key_resp_nbackP2.corr = 1
                else:
                    key_resp_nbackP2.corr = 0
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in pract_nback2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "pract_nback2"-------
    for thisComponent in pract_nback2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    pract_nback2l.addData('pract_nback2stim.started', pract_nback2stim.tStartRefresh)
    pract_nback2l.addData('pract_nback2stim.stopped', pract_nback2stim.tStopRefresh)
    # check responses
    if key_resp_nbackP2.keys in ['', [], None]:  # No response was made
        key_resp_nbackP2.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_nbackP2.corr = 1;  # correct non-response
        else:
           key_resp_nbackP2.corr = 0;  # failed to respond (incorrectly)
    # store data for pract_nback2l (TrialHandler)
    pract_nback2l.addData('key_resp_nbackP2.keys',key_resp_nbackP2.keys)
    pract_nback2l.addData('key_resp_nbackP2.corr', key_resp_nbackP2.corr)
    if key_resp_nbackP2.keys != None:  # we had a response
        pract_nback2l.addData('key_resp_nbackP2.rt', key_resp_nbackP2.rt)
    pract_nback2l.addData('key_resp_nbackP2.started', key_resp_nbackP2.tStartRefresh)
    pract_nback2l.addData('key_resp_nbackP2.stopped', key_resp_nbackP2.tStopRefresh)
    
    # ------Prepare to start Routine "Feedback_Pnback2"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_nbackP2.corr:
        msg7 = "Correct"
    else:
        msg7 = "Wrong"
    text_25.setText(msg7)
    # keep track of which components have finished
    Feedback_Pnback2Components = [text_25]
    for thisComponent in Feedback_Pnback2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Feedback_Pnback2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Feedback_Pnback2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Feedback_Pnback2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Feedback_Pnback2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_25* updates
        if text_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_25.frameNStart = frameN  # exact frame index
            text_25.tStart = t  # local t and not account for scr refresh
            text_25.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_25, 'tStartRefresh')  # time at next scr refresh
            text_25.setAutoDraw(True)
        if text_25.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_25.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_25.tStop = t  # not accounting for scr refresh
                text_25.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_25, 'tStopRefresh')  # time at next scr refresh
                text_25.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Feedback_Pnback2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Feedback_Pnback2"-------
    for thisComponent in Feedback_Pnback2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    pract_nback2l.addData('text_25.started', text_25.tStartRefresh)
    pract_nback2l.addData('text_25.stopped', text_25.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'pract_nback2l'


# ------Prepare to start Routine "Instructions_Nback"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_23.keys = []
key_resp_23.rt = []
_key_resp_23_allKeys = []
# keep track of which components have finished
Instructions_NbackComponents = [text_18, key_resp_23]
for thisComponent in Instructions_NbackComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instructions_NbackClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instructions_Nback"-------
while continueRoutine:
    # get current time
    t = Instructions_NbackClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instructions_NbackClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_18* updates
    if text_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_18.frameNStart = frameN  # exact frame index
        text_18.tStart = t  # local t and not account for scr refresh
        text_18.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_18, 'tStartRefresh')  # time at next scr refresh
        text_18.setAutoDraw(True)
    
    # *key_resp_23* updates
    waitOnFlip = False
    if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_23.frameNStart = frameN  # exact frame index
        key_resp_23.tStart = t  # local t and not account for scr refresh
        key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
        key_resp_23.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_23.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_23.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_23_allKeys.extend(theseKeys)
        if len(_key_resp_23_allKeys):
            key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
            key_resp_23.rt = _key_resp_23_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instructions_NbackComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instructions_Nback"-------
for thisComponent in Instructions_NbackComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_18.started', text_18.tStartRefresh)
thisExp.addData('text_18.stopped', text_18.tStopRefresh)
# check responses
if key_resp_23.keys in ['', [], None]:  # No response was made
    key_resp_23.keys = None
thisExp.addData('key_resp_23.keys',key_resp_23.keys)
if key_resp_23.keys != None:  # we had a response
    thisExp.addData('key_resp_23.rt', key_resp_23.rt)
thisExp.addData('key_resp_23.started', key_resp_23.tStartRefresh)
thisExp.addData('key_resp_23.stopped', key_resp_23.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instructions_Nback" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
test_nback2 = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('nback_2a.xlsx'),
    seed=None, name='test_nback2')
thisExp.addLoop(test_nback2)  # add the loop to the experiment
thisTest_nback2 = test_nback2.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTest_nback2.rgb)
if thisTest_nback2 != None:
    for paramName in thisTest_nback2:
        exec('{} = thisTest_nback2[paramName]'.format(paramName))

for thisTest_nback2 in test_nback2:
    currentLoop = test_nback2
    # abbreviate parameter names if possible (e.g. rgb = thisTest_nback2.rgb)
    if thisTest_nback2 != None:
        for paramName in thisTest_nback2:
            exec('{} = thisTest_nback2[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "nback2"-------
    continueRoutine = True
    routineTimer.add(2.000000)
    # update component parameters for each repeat
    stim.setText(letter)
    key_resp_25.keys = []
    key_resp_25.rt = []
    _key_resp_25_allKeys = []
    # keep track of which components have finished
    nback2Components = [stim, key_resp_25]
    for thisComponent in nback2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    nback2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "nback2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = nback2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=nback2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *stim* updates
        if stim.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            stim.frameNStart = frameN  # exact frame index
            stim.tStart = t  # local t and not account for scr refresh
            stim.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(stim, 'tStartRefresh')  # time at next scr refresh
            stim.setAutoDraw(True)
        if stim.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > stim.tStartRefresh + 0.5-frameTolerance:
                # keep track of stop time/frame for later
                stim.tStop = t  # not accounting for scr refresh
                stim.frameNStop = frameN  # exact frame index
                win.timeOnFlip(stim, 'tStopRefresh')  # time at next scr refresh
                stim.setAutoDraw(False)
        
        # *key_resp_25* updates
        waitOnFlip = False
        if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_25.frameNStart = frameN  # exact frame index
            key_resp_25.tStart = t  # local t and not account for scr refresh
            key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
            key_resp_25.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_25.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_25.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_25.tStop = t  # not accounting for scr refresh
                key_resp_25.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_25, 'tStopRefresh')  # time at next scr refresh
                key_resp_25.status = FINISHED
        if key_resp_25.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_25.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_25_allKeys.extend(theseKeys)
            if len(_key_resp_25_allKeys):
                key_resp_25.keys = [key.name for key in _key_resp_25_allKeys]  # storing all keys
                key_resp_25.rt = [key.rt for key in _key_resp_25_allKeys]
                # was this correct?
                if (key_resp_25.keys == str(corrAns)) or (key_resp_25.keys == corrAns):
                    key_resp_25.corr = 1
                else:
                    key_resp_25.corr = 0
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in nback2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "nback2"-------
    for thisComponent in nback2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    test_nback2.addData('stim.started', stim.tStartRefresh)
    test_nback2.addData('stim.stopped', stim.tStopRefresh)
    # check responses
    if key_resp_25.keys in ['', [], None]:  # No response was made
        key_resp_25.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_25.corr = 1;  # correct non-response
        else:
           key_resp_25.corr = 0;  # failed to respond (incorrectly)
    # store data for test_nback2 (TrialHandler)
    test_nback2.addData('key_resp_25.keys',key_resp_25.keys)
    test_nback2.addData('key_resp_25.corr', key_resp_25.corr)
    if key_resp_25.keys != None:  # we had a response
        test_nback2.addData('key_resp_25.rt', key_resp_25.rt)
    test_nback2.addData('key_resp_25.started', key_resp_25.tStartRefresh)
    test_nback2.addData('key_resp_25.stopped', key_resp_25.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'test_nback2'


# ------Prepare to start Routine "GoodbyeScreen"-------
continueRoutine = True
routineTimer.add(1.500000)
# update component parameters for each repeat
# keep track of which components have finished
GoodbyeScreenComponents = [text_2]
for thisComponent in GoodbyeScreenComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
GoodbyeScreenClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "GoodbyeScreen"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = GoodbyeScreenClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=GoodbyeScreenClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_2* updates
    if text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_2.frameNStart = frameN  # exact frame index
        text_2.tStart = t  # local t and not account for scr refresh
        text_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
        text_2.setAutoDraw(True)
    if text_2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_2.tStartRefresh + 1.5-frameTolerance:
            # keep track of stop time/frame for later
            text_2.tStop = t  # not accounting for scr refresh
            text_2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text_2, 'tStopRefresh')  # time at next scr refresh
            text_2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in GoodbyeScreenComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "GoodbyeScreen"-------
for thisComponent in GoodbyeScreenComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_2.started', text_2.tStartRefresh)
thisExp.addData('text_2.stopped', text_2.tStopRefresh)

# Flip one final time so any remaining win.callOnFlip() 
# and win.timeOnFlip() tasks get executed before quitting
win.flip()

# these shouldn't be strictly necessary (should auto-save)
thisExp.saveAsWideText(filename+'.csv', delim='auto')
thisExp.saveAsPickle(filename)
logging.flush()
# make sure everything is closed down
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()
