#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2021.2.3),
    on March 27, 2023, at 16:10
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

from __future__ import absolute_import, division

from psychopy import locale_setup
from psychopy import prefs
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

from psychopy.hardware import keyboard



# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

# Store info about the experiment session
psychopyVersion = '2021.2.3'
expName = 'diss_code_F-N'  # from the Builder filename that created this script
expInfo = {'ID': '001', 'session': '001'}
dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
expInfo['psychopyVersion'] = psychopyVersion

# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + u'data/%s_%s_%s' % (expInfo['ID'], expName, expInfo['date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
    extraInfo=expInfo, runtimeInfo=None,
    originPath='C:\\Users\\jadamek2\\Desktop\\Dissertation Cognitive Testing 1\\diss_code_F-N_lastrun.py',
    savePickle=True, saveWideText=True,
    dataFileName=filename)
# save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.EXP)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

endExpNow = False  # flag for 'escape' or other condition => quit the exp
frameTolerance = 0.001  # how close to onset before 'same' frame

# Start Code - component code to be run after the window creation

# Setup the Window
win = visual.Window(
    size=[1920, 1200], fullscr=True, screen=0, 
    winType='pyglet', allowGUI=False, allowStencil=False,
    monitor='testMonitor', color='black', colorSpace='rgb',
    blendMode='avg', useFBO=True, 
    units='height')
# store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None:
    frameDur = 1.0 / round(expInfo['frameRate'])
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess

# Setup eyetracking
ioDevice = ioConfig = ioSession = ioServer = eyetracker = None

# create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard()

# Initialize components for Routine "Welcome"
WelcomeClock = core.Clock()
text_welcome = visual.TextStim(win=win, name='text_welcome',
    text='You will be completing two different cognitive tests:\n\n\n1) Flanker Task\n2) N-back Task\n\n\nThere will also be two affect questions asking you how you FEEL and how ACTIVATED you are at the current moment. You will be prompt to respond to these two questions multiple times throughout this process. Specifically, before and after the cognitive tests.\n\n\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_welcome = keyboard.Keyboard()

# Initialize components for Routine "Intro_AffectFS"
Intro_AffectFSClock = core.Clock()
text_InstrFS = visual.TextStim(win=win, name='text_InstrFS',
    text='You will first be asked: "How do you feel RIGHT NOW?"\n\n\n\n\nIt is common to experience changes in how you feel (pleasure vs displeasure) across time. That is, the degree of pleasure and displeasure one feels can fluctuate. When asked "How do you feel RIGHT NOW?" make sure you respond to how you feel at that exact moment. Do not over think it. Try to respond immediately. You will respond by clicking where on the scale (pleasure to displeasure) you currently feel. \n\n\n\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_InstrAff = keyboard.Keyboard()

# Initialize components for Routine "Intro_AffectFAS"
Intro_AffectFASClock = core.Clock()
text_InstrFAS = visual.TextStim(win=win, name='text_InstrFAS',
    text='Next you will be asked: "How aroused do you feel RIGHT NOW?"\n\n\n\nThis second affect question relates to how \'aroused\' you feel as it is also common to experience fluctuations in level of arousal . Here, \'aroused\' refers to how \'activated\' or \'worked-up\' you feel. You might experience high activation in one of a variety of ways, for example as excitement or anger or anxiety. Low activation might be experienced in a number of different ways, for example as relaxation or boredom or calmness.\n\n\nAgain make sure you respond to how you feel at that exact moment. Do not over think it. Try to respond immediately. You will respond by clicking where on the scale (low activation to high activation) you currently feel. \n\n\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_InstrFAS = keyboard.Keyboard()

# Initialize components for Routine "FS"
FSClock = core.Clock()
text_fs = visual.TextStim(win=win, name='text_fs',
    text='How do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .3), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FS1 = visual.Slider(win=win, name='FS1',
    startValue=None, size=(1.0, 0.1), pos=(0, 0), units=None,
    labels=["Displeasure", "Pleasure"], ticks=(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.03,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "FAS"
FASClock = core.Clock()
text_fas = visual.TextStim(win=win, name='text_fas',
    text='How aroused "activated" do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .4), height=0.05, wrapWidth=5.0, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FAS1 = visual.Slider(win=win, name='FAS1',
    startValue=None, size=(0.1, .5), pos=(0, -.1), units=None,
    labels=["Low Arousal", "High Arousal"], ticks=(1, 2, 3, 4, 5, 6), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.04,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "Instr_flanker_P"
Instr_flanker_PClock = core.Clock()
text_Instr_flankP = visual.TextStim(win=win, name='text_Instr_flankP',
    text='You will now complete the Flanker Task\n\n\n\nA series of five arrows will be briefly presented in the center of the screen.\n\nYour task is to indicate whether the center arrow is facing left (by pressing A) or right (by pressing L). For example, if presented with <<><< the center arrow is facing to the right (>) so you would press the L key.\n\nRemember it is VERY important to respond both as quickly and as accurately as possible!\n\nPress space to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_InstrFP = keyboard.Keyboard()

# Initialize components for Routine "Flank_PractTrial"
Flank_PractTrialClock = core.Clock()
text_FlankPT = visual.TextStim(win=win, name='text_FlankPT',
    text="You will now begin the PRACTICE trial.\n\n\n\nPlace your left index finger on the 'A' key\nPlace your right index finger on the 'L' key\n\nYou will be given feedback after each response \n\n\n\nPress SPACEBAR when ready to begin ",
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_FlankPT = keyboard.Keyboard()

# Initialize components for Routine "fixation"
fixationClock = core.Clock()
textFix = visual.TextStim(win=win, name='textFix',
    text='+',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Flanker_P"
Flanker_PClock = core.Clock()
textFlankerPrac = visual.TextStim(win=win, name='textFlankerPrac',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "ITI_P"
ITI_PClock = core.Clock()
textITI_P = visual.TextStim(win=win, name='textITI_P',
    text=None,
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_Flank_P = keyboard.Keyboard()

# Initialize components for Routine "Flanker_Feedback_P"
Flanker_Feedback_PClock = core.Clock()
text_flankP_feedback = visual.TextStim(win=win, name='text_flankP_feedback',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "FS"
FSClock = core.Clock()
text_fs = visual.TextStim(win=win, name='text_fs',
    text='How do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .3), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FS1 = visual.Slider(win=win, name='FS1',
    startValue=None, size=(1.0, 0.1), pos=(0, 0), units=None,
    labels=["Displeasure", "Pleasure"], ticks=(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.03,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "FAS"
FASClock = core.Clock()
text_fas = visual.TextStim(win=win, name='text_fas',
    text='How aroused "activated" do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .4), height=0.05, wrapWidth=5.0, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FAS1 = visual.Slider(win=win, name='FAS1',
    startValue=None, size=(0.1, .5), pos=(0, -.1), units=None,
    labels=["Low Arousal", "High Arousal"], ticks=(1, 2, 3, 4, 5, 6), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.04,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "Instr_flanker_T"
Instr_flanker_TClock = core.Clock()
text_Instr_flankT = visual.TextStim(win=win, name='text_Instr_flankT',
    text="You will now complete the TEST trial.\n\nThere are 3 blocks in total, with a break and the two-question prompt before continuing\n\nRemember to respond as quickly and accurately as possible\n\nPlace your left index finger on the 'A' key\nPlace your right index finger on the 'L' key\n\n\nPress SPACEBAR when ready to begin",
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_InstrFT = keyboard.Keyboard()

# Initialize components for Routine "InstructionBlock"
InstructionBlockClock = core.Clock()
textInstrBlock1 = visual.TextStim(win=win, name='textInstrBlock1',
    text='You are about to begin the next Block.\n\n\nRemember it is VERY important to respond both as quickly and as accurately as possible!\n\n\nPress SPACEBAR when you are ready to start',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_Block1 = keyboard.Keyboard()

# Initialize components for Routine "fixation"
fixationClock = core.Clock()
textFix = visual.TextStim(win=win, name='textFix',
    text='+',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "Flanker_T"
Flanker_TClock = core.Clock()
textFlankerTest = visual.TextStim(win=win, name='textFlankerTest',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "ITI_T"
ITI_TClock = core.Clock()
textITI_T = visual.TextStim(win=win, name='textITI_T',
    text=None,
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_Flank_T = keyboard.Keyboard()

# Initialize components for Routine "BlockTxt"
BlockTxtClock = core.Clock()
text_block = visual.TextStim(win=win, name='text_block',
    text='You just completed a block\n\nYou will be asked 2 affect questions before moving on\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_blockfb = keyboard.Keyboard()

# Initialize components for Routine "FS"
FSClock = core.Clock()
text_fs = visual.TextStim(win=win, name='text_fs',
    text='How do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .3), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FS1 = visual.Slider(win=win, name='FS1',
    startValue=None, size=(1.0, 0.1), pos=(0, 0), units=None,
    labels=["Displeasure", "Pleasure"], ticks=(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.03,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "FAS"
FASClock = core.Clock()
text_fas = visual.TextStim(win=win, name='text_fas',
    text='How aroused "activated" do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .4), height=0.05, wrapWidth=5.0, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FAS1 = visual.Slider(win=win, name='FAS1',
    startValue=None, size=(0.1, .5), pos=(0, -.1), units=None,
    labels=["Low Arousal", "High Arousal"], ticks=(1, 2, 3, 4, 5, 6), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.04,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "Nback"
NbackClock = core.Clock()
text_2back = visual.TextStim(win=win, name='text_2back',
    text='You will now begin the N-back task.\n\nThere will be two conditions (2-back and 3-back). Please pay attention to the instructions.\n\nThere will be a practice trial followed by a test trial for each condition\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_2back = keyboard.Keyboard()

# Initialize components for Routine "Instr_2back_P"
Instr_2back_PClock = core.Clock()
text_2backP = visual.TextStim(win=win, name='text_2backP',
    text='You will now begin the PRACTICE trial for the 2-back test\n\nYou will be presented a sequence of letters one-by-one. For each letter presented, decide if the current letter is the same (\'A\' key) as the one presented 2 trials ago or not (\'L\' key). \n\nYou will press the \'A\' key with your left index finger if the letter is a match. \nYou will press the \'L\' key with your right index finger if the letter is a mismatch.\n\nFor example, in the following sequence of three letters, "b" ... "c" ... "b" ... the third trial ("b") is the same as the trial presented 2 letters ago ("b"), thus you would press the \'A\' key. In the example, "n" ... "t" ... "t", the third trial ("t") is different from the trial presented 2 letters ago ("n"), thus you would press the \'L\' key. \n\nPlace your left index finger on the \'A\' key\nPlace your right index finger on the \'L\' key\n\nPlease respond as quickly and accurately as possible.\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_2P = keyboard.Keyboard()

# Initialize components for Routine "Nback2_P"
Nback2_PClock = core.Clock()
stim_pract_2back = visual.TextStim(win=win, name='stim_pract_2back',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_2backP = keyboard.Keyboard()

# Initialize components for Routine "Nback2_FeedbackP"
Nback2_FeedbackPClock = core.Clock()
text_feedback2back = visual.TextStim(win=win, name='text_feedback2back',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "FS"
FSClock = core.Clock()
text_fs = visual.TextStim(win=win, name='text_fs',
    text='How do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .3), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FS1 = visual.Slider(win=win, name='FS1',
    startValue=None, size=(1.0, 0.1), pos=(0, 0), units=None,
    labels=["Displeasure", "Pleasure"], ticks=(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.03,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "FAS"
FASClock = core.Clock()
text_fas = visual.TextStim(win=win, name='text_fas',
    text='How aroused "activated" do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .4), height=0.05, wrapWidth=5.0, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FAS1 = visual.Slider(win=win, name='FAS1',
    startValue=None, size=(0.1, .5), pos=(0, -.1), units=None,
    labels=["Low Arousal", "High Arousal"], ticks=(1, 2, 3, 4, 5, 6), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.04,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "Instr_2back_T"
Instr_2back_TClock = core.Clock()
text_2backT = visual.TextStim(win=win, name='text_2backT',
    text='You will now begin the Test Trial\n\n\nRemember, press the \'A\' key only if the letter presented is the same as the one presented 2 letters ago ("b" ... "c" ... "b") otherwise, press the \'L\' key ( "n" ... "t" ... "t"). \n\n\nPress SPACEBAR to continue\n',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_2 = keyboard.Keyboard()

# Initialize components for Routine "InstructionBlock"
InstructionBlockClock = core.Clock()
textInstrBlock1 = visual.TextStim(win=win, name='textInstrBlock1',
    text='You are about to begin the next Block.\n\n\nRemember it is VERY important to respond both as quickly and as accurately as possible!\n\n\nPress SPACEBAR when you are ready to start',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_Block1 = keyboard.Keyboard()

# Initialize components for Routine "Nback2_T"
Nback2_TClock = core.Clock()
stim_test_2back = visual.TextStim(win=win, name='stim_test_2back',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_2backT = keyboard.Keyboard()

# Initialize components for Routine "BlockTxt"
BlockTxtClock = core.Clock()
text_block = visual.TextStim(win=win, name='text_block',
    text='You just completed a block\n\nYou will be asked 2 affect questions before moving on\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_blockfb = keyboard.Keyboard()

# Initialize components for Routine "FS"
FSClock = core.Clock()
text_fs = visual.TextStim(win=win, name='text_fs',
    text='How do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .3), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FS1 = visual.Slider(win=win, name='FS1',
    startValue=None, size=(1.0, 0.1), pos=(0, 0), units=None,
    labels=["Displeasure", "Pleasure"], ticks=(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.03,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "FAS"
FASClock = core.Clock()
text_fas = visual.TextStim(win=win, name='text_fas',
    text='How aroused "activated" do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .4), height=0.05, wrapWidth=5.0, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FAS1 = visual.Slider(win=win, name='FAS1',
    startValue=None, size=(0.1, .5), pos=(0, -.1), units=None,
    labels=["Low Arousal", "High Arousal"], ticks=(1, 2, 3, 4, 5, 6), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.04,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "Instr_3back_P"
Instr_3back_PClock = core.Clock()
text_3backP = visual.TextStim(win=win, name='text_3backP',
    text='You have just completed the 2-back test\n\nYou will now perform the Practice Trial for the 3-back test\n\nNow, instead of remembering the two previous letters you will have to remember the three previous letters\n\nYou will be presented a sequence of letters one-by-one. For each letter presented, decide if the current letter is the same as the one presented 3 trials ago." For example, in the following sequence of three letters, "b" ... "c" ... "d" ... "b" the fourth trial ("b") is the same as the trial presented 3 letters ago ("b"), thus you would press the \'a\' key. \n\nIn the example, "n" ... "c" ... "n" ... "t", the fourth trial ("t") is different from the trial presented 3 letters ago ("n" ), thus you would press the \'l\' key.\n\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_3P = keyboard.Keyboard()

# Initialize components for Routine "Nback3_P"
Nback3_PClock = core.Clock()
stim_pract_3back = visual.TextStim(win=win, name='stim_pract_3back',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_3backP = keyboard.Keyboard()

# Initialize components for Routine "Nback3_FeedbackP"
Nback3_FeedbackPClock = core.Clock()
text_feedback3back = visual.TextStim(win=win, name='text_feedback3back',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);

# Initialize components for Routine "FS"
FSClock = core.Clock()
text_fs = visual.TextStim(win=win, name='text_fs',
    text='How do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .3), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FS1 = visual.Slider(win=win, name='FS1',
    startValue=None, size=(1.0, 0.1), pos=(0, 0), units=None,
    labels=["Displeasure", "Pleasure"], ticks=(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.03,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "FAS"
FASClock = core.Clock()
text_fas = visual.TextStim(win=win, name='text_fas',
    text='How aroused "activated" do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .4), height=0.05, wrapWidth=5.0, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FAS1 = visual.Slider(win=win, name='FAS1',
    startValue=None, size=(0.1, .5), pos=(0, -.1), units=None,
    labels=["Low Arousal", "High Arousal"], ticks=(1, 2, 3, 4, 5, 6), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.04,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "Instr_3back_T"
Instr_3back_TClock = core.Clock()
text_3backT = visual.TextStim(win=win, name='text_3backT',
    text='You will now begin the Test Trial\n\nRemember, press the \'a\' key only if the letter presented is the same as the one presented 3 letters ago ("b" ... "c" ... "r" ... "b") otherwise, press the \'l\' key ( "b" ... "c" ... "r" ... "t"). \n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp = keyboard.Keyboard()

# Initialize components for Routine "InstructionBlock"
InstructionBlockClock = core.Clock()
textInstrBlock1 = visual.TextStim(win=win, name='textInstrBlock1',
    text='You are about to begin the next Block.\n\n\nRemember it is VERY important to respond both as quickly and as accurately as possible!\n\n\nPress SPACEBAR when you are ready to start',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_Block1 = keyboard.Keyboard()

# Initialize components for Routine "Nback3_T"
Nback3_TClock = core.Clock()
stim_test_3back = visual.TextStim(win=win, name='stim_test_3back',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_3backT = keyboard.Keyboard()

# Initialize components for Routine "BlockTxt"
BlockTxtClock = core.Clock()
text_block = visual.TextStim(win=win, name='text_block',
    text='You just completed a block\n\nYou will be asked 2 affect questions before moving on\n\nRemember to respond as quickly and accurately as possible.\n\nPress SPACEBAR to continue',
    font='Open Sans',
    pos=(0, 0), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=1.0, 
    languageStyle='LTR',
    depth=0.0);
key_resp_blockfb = keyboard.Keyboard()

# Initialize components for Routine "FS"
FSClock = core.Clock()
text_fs = visual.TextStim(win=win, name='text_fs',
    text='How do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .3), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FS1 = visual.Slider(win=win, name='FS1',
    startValue=None, size=(1.0, 0.1), pos=(0, 0), units=None,
    labels=["Displeasure", "Pleasure"], ticks=(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.03,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "FAS"
FASClock = core.Clock()
text_fas = visual.TextStim(win=win, name='text_fas',
    text='How aroused "activated" do you feel RIGHT NOW?',
    font='Open Sans',
    pos=(0, .4), height=0.05, wrapWidth=5.0, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
FAS1 = visual.Slider(win=win, name='FAS1',
    startValue=None, size=(0.1, .5), pos=(0, -.1), units=None,
    labels=["Low Arousal", "High Arousal"], ticks=(1, 2, 3, 4, 5, 6), granularity=0.0,
    style='rating', styleTweaks=(), opacity=None,
    color='LightGray', fillColor='Red', borderColor='White', colorSpace='rgb',
    font='Open Sans', labelHeight=0.04,
    flip=False, depth=-1, readOnly=False)

# Initialize components for Routine "GoodBye"
GoodByeClock = core.Clock()
Goodbye = visual.TextStim(win=win, name='Goodbye',
    text="You're all done!\n\nThank you for participating\n\nPress SPACEBAR to Finish!!",
    font='Open Sans',
    pos=(0, 0), height=0.07, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_3 = keyboard.Keyboard()

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 

# ------Prepare to start Routine "Welcome"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_welcome.keys = []
key_resp_welcome.rt = []
_key_resp_welcome_allKeys = []
# keep track of which components have finished
WelcomeComponents = [text_welcome, key_resp_welcome]
for thisComponent in WelcomeComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
WelcomeClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Welcome"-------
while continueRoutine:
    # get current time
    t = WelcomeClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=WelcomeClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_welcome* updates
    if text_welcome.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_welcome.frameNStart = frameN  # exact frame index
        text_welcome.tStart = t  # local t and not account for scr refresh
        text_welcome.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_welcome, 'tStartRefresh')  # time at next scr refresh
        text_welcome.setAutoDraw(True)
    
    # *key_resp_welcome* updates
    waitOnFlip = False
    if key_resp_welcome.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_welcome.frameNStart = frameN  # exact frame index
        key_resp_welcome.tStart = t  # local t and not account for scr refresh
        key_resp_welcome.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_welcome, 'tStartRefresh')  # time at next scr refresh
        key_resp_welcome.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_welcome.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_welcome.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_welcome.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_welcome.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_welcome_allKeys.extend(theseKeys)
        if len(_key_resp_welcome_allKeys):
            key_resp_welcome.keys = _key_resp_welcome_allKeys[0].name  # just the first key pressed
            key_resp_welcome.rt = _key_resp_welcome_allKeys[0].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in WelcomeComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Welcome"-------
for thisComponent in WelcomeComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_welcome.started', text_welcome.tStartRefresh)
thisExp.addData('text_welcome.stopped', text_welcome.tStopRefresh)
# check responses
if key_resp_welcome.keys in ['', [], None]:  # No response was made
    key_resp_welcome.keys = None
thisExp.addData('key_resp_welcome.keys',key_resp_welcome.keys)
if key_resp_welcome.keys != None:  # we had a response
    thisExp.addData('key_resp_welcome.rt', key_resp_welcome.rt)
thisExp.addData('key_resp_welcome.started', key_resp_welcome.tStartRefresh)
thisExp.addData('key_resp_welcome.stopped', key_resp_welcome.tStopRefresh)
thisExp.nextEntry()
# the Routine "Welcome" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Intro_AffectFS"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_InstrAff.keys = []
key_resp_InstrAff.rt = []
_key_resp_InstrAff_allKeys = []
# keep track of which components have finished
Intro_AffectFSComponents = [text_InstrFS, key_resp_InstrAff]
for thisComponent in Intro_AffectFSComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Intro_AffectFSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Intro_AffectFS"-------
while continueRoutine:
    # get current time
    t = Intro_AffectFSClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Intro_AffectFSClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_InstrFS* updates
    if text_InstrFS.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_InstrFS.frameNStart = frameN  # exact frame index
        text_InstrFS.tStart = t  # local t and not account for scr refresh
        text_InstrFS.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_InstrFS, 'tStartRefresh')  # time at next scr refresh
        text_InstrFS.setAutoDraw(True)
    
    # *key_resp_InstrAff* updates
    waitOnFlip = False
    if key_resp_InstrAff.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_InstrAff.frameNStart = frameN  # exact frame index
        key_resp_InstrAff.tStart = t  # local t and not account for scr refresh
        key_resp_InstrAff.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_InstrAff, 'tStartRefresh')  # time at next scr refresh
        key_resp_InstrAff.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_InstrAff.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_InstrAff.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_InstrAff.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_InstrAff.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_InstrAff_allKeys.extend(theseKeys)
        if len(_key_resp_InstrAff_allKeys):
            key_resp_InstrAff.keys = _key_resp_InstrAff_allKeys[-1].name  # just the last key pressed
            key_resp_InstrAff.rt = _key_resp_InstrAff_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Intro_AffectFSComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Intro_AffectFS"-------
for thisComponent in Intro_AffectFSComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_InstrFS.started', text_InstrFS.tStartRefresh)
thisExp.addData('text_InstrFS.stopped', text_InstrFS.tStopRefresh)
# check responses
if key_resp_InstrAff.keys in ['', [], None]:  # No response was made
    key_resp_InstrAff.keys = None
thisExp.addData('key_resp_InstrAff.keys',key_resp_InstrAff.keys)
if key_resp_InstrAff.keys != None:  # we had a response
    thisExp.addData('key_resp_InstrAff.rt', key_resp_InstrAff.rt)
thisExp.addData('key_resp_InstrAff.started', key_resp_InstrAff.tStartRefresh)
thisExp.addData('key_resp_InstrAff.stopped', key_resp_InstrAff.tStopRefresh)
thisExp.nextEntry()
# the Routine "Intro_AffectFS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Intro_AffectFAS"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_InstrFAS.keys = []
key_resp_InstrFAS.rt = []
_key_resp_InstrFAS_allKeys = []
# keep track of which components have finished
Intro_AffectFASComponents = [text_InstrFAS, key_resp_InstrFAS]
for thisComponent in Intro_AffectFASComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Intro_AffectFASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Intro_AffectFAS"-------
while continueRoutine:
    # get current time
    t = Intro_AffectFASClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Intro_AffectFASClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_InstrFAS* updates
    if text_InstrFAS.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_InstrFAS.frameNStart = frameN  # exact frame index
        text_InstrFAS.tStart = t  # local t and not account for scr refresh
        text_InstrFAS.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_InstrFAS, 'tStartRefresh')  # time at next scr refresh
        text_InstrFAS.setAutoDraw(True)
    
    # *key_resp_InstrFAS* updates
    waitOnFlip = False
    if key_resp_InstrFAS.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_InstrFAS.frameNStart = frameN  # exact frame index
        key_resp_InstrFAS.tStart = t  # local t and not account for scr refresh
        key_resp_InstrFAS.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_InstrFAS, 'tStartRefresh')  # time at next scr refresh
        key_resp_InstrFAS.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_InstrFAS.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_InstrFAS.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_InstrFAS.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_InstrFAS.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_InstrFAS_allKeys.extend(theseKeys)
        if len(_key_resp_InstrFAS_allKeys):
            key_resp_InstrFAS.keys = _key_resp_InstrFAS_allKeys[-1].name  # just the last key pressed
            key_resp_InstrFAS.rt = _key_resp_InstrFAS_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Intro_AffectFASComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Intro_AffectFAS"-------
for thisComponent in Intro_AffectFASComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_InstrFAS.started', text_InstrFAS.tStartRefresh)
thisExp.addData('text_InstrFAS.stopped', text_InstrFAS.tStopRefresh)
# check responses
if key_resp_InstrFAS.keys in ['', [], None]:  # No response was made
    key_resp_InstrFAS.keys = None
thisExp.addData('key_resp_InstrFAS.keys',key_resp_InstrFAS.keys)
if key_resp_InstrFAS.keys != None:  # we had a response
    thisExp.addData('key_resp_InstrFAS.rt', key_resp_InstrFAS.rt)
thisExp.addData('key_resp_InstrFAS.started', key_resp_InstrFAS.tStartRefresh)
thisExp.addData('key_resp_InstrFAS.stopped', key_resp_InstrFAS.tStopRefresh)
thisExp.nextEntry()
# the Routine "Intro_AffectFAS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FS"-------
continueRoutine = True
# update component parameters for each repeat
FS1.reset()
FS1.marker.size = (.03, .03)
# keep track of which components have finished
FSComponents = [text_fs, FS1]
for thisComponent in FSComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FS"-------
while continueRoutine:
    # get current time
    t = FSClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FSClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fs* updates
    if text_fs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fs.frameNStart = frameN  # exact frame index
        text_fs.tStart = t  # local t and not account for scr refresh
        text_fs.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fs, 'tStartRefresh')  # time at next scr refresh
        text_fs.setAutoDraw(True)
    
    # *FS1* updates
    if FS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FS1.frameNStart = frameN  # exact frame index
        FS1.tStart = t  # local t and not account for scr refresh
        FS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FS1, 'tStartRefresh')  # time at next scr refresh
        FS1.setAutoDraw(True)
    
    # Check FS1 for response to end routine
    if FS1.getRating() is not None and FS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FS"-------
for thisComponent in FSComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fs.started', text_fs.tStartRefresh)
thisExp.addData('text_fs.stopped', text_fs.tStopRefresh)
thisExp.addData('FS1.response', FS1.getRating())
thisExp.addData('FS1.rt', FS1.getRT())
thisExp.addData('FS1.started', FS1.tStartRefresh)
thisExp.addData('FS1.stopped', FS1.tStopRefresh)
# the Routine "FS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FAS"-------
continueRoutine = True
# update component parameters for each repeat
FAS1.reset()
FAS1.marker.size = (.03, .03)
# keep track of which components have finished
FASComponents = [text_fas, FAS1]
for thisComponent in FASComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FAS"-------
while continueRoutine:
    # get current time
    t = FASClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FASClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fas* updates
    if text_fas.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fas.frameNStart = frameN  # exact frame index
        text_fas.tStart = t  # local t and not account for scr refresh
        text_fas.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fas, 'tStartRefresh')  # time at next scr refresh
        text_fas.setAutoDraw(True)
    
    # *FAS1* updates
    if FAS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FAS1.frameNStart = frameN  # exact frame index
        FAS1.tStart = t  # local t and not account for scr refresh
        FAS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FAS1, 'tStartRefresh')  # time at next scr refresh
        FAS1.setAutoDraw(True)
    
    # Check FAS1 for response to end routine
    if FAS1.getRating() is not None and FAS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FASComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FAS"-------
for thisComponent in FASComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fas.started', text_fas.tStartRefresh)
thisExp.addData('text_fas.stopped', text_fas.tStopRefresh)
thisExp.addData('FAS1.response', FAS1.getRating())
thisExp.addData('FAS1.rt', FAS1.getRT())
thisExp.addData('FAS1.started', FAS1.tStartRefresh)
thisExp.addData('FAS1.stopped', FAS1.tStopRefresh)
# the Routine "FAS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Instr_flanker_P"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_InstrFP.keys = []
key_resp_InstrFP.rt = []
_key_resp_InstrFP_allKeys = []
# keep track of which components have finished
Instr_flanker_PComponents = [text_Instr_flankP, key_resp_InstrFP]
for thisComponent in Instr_flanker_PComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instr_flanker_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instr_flanker_P"-------
while continueRoutine:
    # get current time
    t = Instr_flanker_PClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instr_flanker_PClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_Instr_flankP* updates
    if text_Instr_flankP.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Instr_flankP.frameNStart = frameN  # exact frame index
        text_Instr_flankP.tStart = t  # local t and not account for scr refresh
        text_Instr_flankP.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Instr_flankP, 'tStartRefresh')  # time at next scr refresh
        text_Instr_flankP.setAutoDraw(True)
    
    # *key_resp_InstrFP* updates
    waitOnFlip = False
    if key_resp_InstrFP.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_InstrFP.frameNStart = frameN  # exact frame index
        key_resp_InstrFP.tStart = t  # local t and not account for scr refresh
        key_resp_InstrFP.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_InstrFP, 'tStartRefresh')  # time at next scr refresh
        key_resp_InstrFP.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_InstrFP.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_InstrFP.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_InstrFP.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_InstrFP.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_InstrFP_allKeys.extend(theseKeys)
        if len(_key_resp_InstrFP_allKeys):
            key_resp_InstrFP.keys = _key_resp_InstrFP_allKeys[-1].name  # just the last key pressed
            key_resp_InstrFP.rt = _key_resp_InstrFP_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instr_flanker_PComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instr_flanker_P"-------
for thisComponent in Instr_flanker_PComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_Instr_flankP.started', text_Instr_flankP.tStartRefresh)
thisExp.addData('text_Instr_flankP.stopped', text_Instr_flankP.tStopRefresh)
# check responses
if key_resp_InstrFP.keys in ['', [], None]:  # No response was made
    key_resp_InstrFP.keys = None
thisExp.addData('key_resp_InstrFP.keys',key_resp_InstrFP.keys)
if key_resp_InstrFP.keys != None:  # we had a response
    thisExp.addData('key_resp_InstrFP.rt', key_resp_InstrFP.rt)
thisExp.addData('key_resp_InstrFP.started', key_resp_InstrFP.tStartRefresh)
thisExp.addData('key_resp_InstrFP.stopped', key_resp_InstrFP.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instr_flanker_P" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Flank_PractTrial"-------
continueRoutine = True
# update component parameters for each repeat
key_FlankPT.keys = []
key_FlankPT.rt = []
_key_FlankPT_allKeys = []
# keep track of which components have finished
Flank_PractTrialComponents = [text_FlankPT, key_FlankPT]
for thisComponent in Flank_PractTrialComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Flank_PractTrialClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Flank_PractTrial"-------
while continueRoutine:
    # get current time
    t = Flank_PractTrialClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Flank_PractTrialClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_FlankPT* updates
    if text_FlankPT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_FlankPT.frameNStart = frameN  # exact frame index
        text_FlankPT.tStart = t  # local t and not account for scr refresh
        text_FlankPT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_FlankPT, 'tStartRefresh')  # time at next scr refresh
        text_FlankPT.setAutoDraw(True)
    
    # *key_FlankPT* updates
    waitOnFlip = False
    if key_FlankPT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_FlankPT.frameNStart = frameN  # exact frame index
        key_FlankPT.tStart = t  # local t and not account for scr refresh
        key_FlankPT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_FlankPT, 'tStartRefresh')  # time at next scr refresh
        key_FlankPT.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_FlankPT.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_FlankPT.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_FlankPT.status == STARTED and not waitOnFlip:
        theseKeys = key_FlankPT.getKeys(keyList=['space'], waitRelease=False)
        _key_FlankPT_allKeys.extend(theseKeys)
        if len(_key_FlankPT_allKeys):
            key_FlankPT.keys = _key_FlankPT_allKeys[-1].name  # just the last key pressed
            key_FlankPT.rt = _key_FlankPT_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Flank_PractTrialComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Flank_PractTrial"-------
for thisComponent in Flank_PractTrialComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_FlankPT.started', text_FlankPT.tStartRefresh)
thisExp.addData('text_FlankPT.stopped', text_FlankPT.tStopRefresh)
# check responses
if key_FlankPT.keys in ['', [], None]:  # No response was made
    key_FlankPT.keys = None
thisExp.addData('key_FlankPT.keys',key_FlankPT.keys)
if key_FlankPT.keys != None:  # we had a response
    thisExp.addData('key_FlankPT.rt', key_FlankPT.rt)
thisExp.addData('key_FlankPT.started', key_FlankPT.tStartRefresh)
thisExp.addData('key_FlankPT.stopped', key_FlankPT.tStopRefresh)
thisExp.nextEntry()
# the Routine "Flank_PractTrial" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
PracFlankLoop = data.TrialHandler(nReps=1.0, method='fullRandom', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Files/FlankPrac.xlsx'),
    seed=None, name='PracFlankLoop')
thisExp.addLoop(PracFlankLoop)  # add the loop to the experiment
thisPracFlankLoop = PracFlankLoop.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPracFlankLoop.rgb)
if thisPracFlankLoop != None:
    for paramName in thisPracFlankLoop:
        exec('{} = thisPracFlankLoop[paramName]'.format(paramName))

for thisPracFlankLoop in PracFlankLoop:
    currentLoop = PracFlankLoop
    # abbreviate parameter names if possible (e.g. rgb = thisPracFlankLoop.rgb)
    if thisPracFlankLoop != None:
        for paramName in thisPracFlankLoop:
            exec('{} = thisPracFlankLoop[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "fixation"-------
    continueRoutine = True
    routineTimer.add(0.500000)
    # update component parameters for each repeat
    # keep track of which components have finished
    fixationComponents = [textFix]
    for thisComponent in fixationComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fixationClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fixation"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fixationClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fixationClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *textFix* updates
        if textFix.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textFix.frameNStart = frameN  # exact frame index
            textFix.tStart = t  # local t and not account for scr refresh
            textFix.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textFix, 'tStartRefresh')  # time at next scr refresh
            textFix.setAutoDraw(True)
        if textFix.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > textFix.tStartRefresh + 0.5-frameTolerance:
                # keep track of stop time/frame for later
                textFix.tStop = t  # not accounting for scr refresh
                textFix.frameNStop = frameN  # exact frame index
                win.timeOnFlip(textFix, 'tStopRefresh')  # time at next scr refresh
                textFix.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fixationComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fixation"-------
    for thisComponent in fixationComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    PracFlankLoop.addData('textFix.started', textFix.tStartRefresh)
    PracFlankLoop.addData('textFix.stopped', textFix.tStopRefresh)
    
    # ------Prepare to start Routine "Flanker_P"-------
    continueRoutine = True
    routineTimer.add(0.100000)
    # update component parameters for each repeat
    textFlankerPrac.setText(Stimulus)
    # keep track of which components have finished
    Flanker_PComponents = [textFlankerPrac]
    for thisComponent in Flanker_PComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Flanker_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Flanker_P"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Flanker_PClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Flanker_PClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *textFlankerPrac* updates
        if textFlankerPrac.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textFlankerPrac.frameNStart = frameN  # exact frame index
            textFlankerPrac.tStart = t  # local t and not account for scr refresh
            textFlankerPrac.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textFlankerPrac, 'tStartRefresh')  # time at next scr refresh
            textFlankerPrac.setAutoDraw(True)
        if textFlankerPrac.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > textFlankerPrac.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                textFlankerPrac.tStop = t  # not accounting for scr refresh
                textFlankerPrac.frameNStop = frameN  # exact frame index
                win.timeOnFlip(textFlankerPrac, 'tStopRefresh')  # time at next scr refresh
                textFlankerPrac.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Flanker_PComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Flanker_P"-------
    for thisComponent in Flanker_PComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    PracFlankLoop.addData('textFlankerPrac.started', textFlankerPrac.tStartRefresh)
    PracFlankLoop.addData('textFlankerPrac.stopped', textFlankerPrac.tStopRefresh)
    
    # ------Prepare to start Routine "ITI_P"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_Flank_P.keys = []
    key_resp_Flank_P.rt = []
    _key_resp_Flank_P_allKeys = []
    # keep track of which components have finished
    ITI_PComponents = [textITI_P, key_resp_Flank_P]
    for thisComponent in ITI_PComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    ITI_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "ITI_P"-------
    while continueRoutine:
        # get current time
        t = ITI_PClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=ITI_PClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *textITI_P* updates
        if textITI_P.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textITI_P.frameNStart = frameN  # exact frame index
            textITI_P.tStart = t  # local t and not account for scr refresh
            textITI_P.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textITI_P, 'tStartRefresh')  # time at next scr refresh
            textITI_P.setAutoDraw(True)
        if textITI_P.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > textITI_P.tStartRefresh + ITI-frameTolerance:
                # keep track of stop time/frame for later
                textITI_P.tStop = t  # not accounting for scr refresh
                textITI_P.frameNStop = frameN  # exact frame index
                win.timeOnFlip(textITI_P, 'tStopRefresh')  # time at next scr refresh
                textITI_P.setAutoDraw(False)
        
        # *key_resp_Flank_P* updates
        waitOnFlip = False
        if key_resp_Flank_P.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_Flank_P.frameNStart = frameN  # exact frame index
            key_resp_Flank_P.tStart = t  # local t and not account for scr refresh
            key_resp_Flank_P.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_Flank_P, 'tStartRefresh')  # time at next scr refresh
            key_resp_Flank_P.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_Flank_P.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_Flank_P.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_Flank_P.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_Flank_P.tStartRefresh + ITI-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_Flank_P.tStop = t  # not accounting for scr refresh
                key_resp_Flank_P.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_Flank_P, 'tStopRefresh')  # time at next scr refresh
                key_resp_Flank_P.status = FINISHED
        if key_resp_Flank_P.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_Flank_P.getKeys(keyList=['a', 'l'], waitRelease=False)
            _key_resp_Flank_P_allKeys.extend(theseKeys)
            if len(_key_resp_Flank_P_allKeys):
                key_resp_Flank_P.keys = _key_resp_Flank_P_allKeys[0].name  # just the first key pressed
                key_resp_Flank_P.rt = _key_resp_Flank_P_allKeys[0].rt
                # was this correct?
                if (key_resp_Flank_P.keys == str(CorrectResp)) or (key_resp_Flank_P.keys == CorrectResp):
                    key_resp_Flank_P.corr = 1
                else:
                    key_resp_Flank_P.corr = 0
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in ITI_PComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "ITI_P"-------
    for thisComponent in ITI_PComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    PracFlankLoop.addData('textITI_P.started', textITI_P.tStartRefresh)
    PracFlankLoop.addData('textITI_P.stopped', textITI_P.tStopRefresh)
    # check responses
    if key_resp_Flank_P.keys in ['', [], None]:  # No response was made
        key_resp_Flank_P.keys = None
        # was no response the correct answer?!
        if str(CorrectResp).lower() == 'none':
           key_resp_Flank_P.corr = 1;  # correct non-response
        else:
           key_resp_Flank_P.corr = 0;  # failed to respond (incorrectly)
    # store data for PracFlankLoop (TrialHandler)
    PracFlankLoop.addData('key_resp_Flank_P.keys',key_resp_Flank_P.keys)
    PracFlankLoop.addData('key_resp_Flank_P.corr', key_resp_Flank_P.corr)
    if key_resp_Flank_P.keys != None:  # we had a response
        PracFlankLoop.addData('key_resp_Flank_P.rt', key_resp_Flank_P.rt)
    PracFlankLoop.addData('key_resp_Flank_P.started', key_resp_Flank_P.tStartRefresh)
    PracFlankLoop.addData('key_resp_Flank_P.stopped', key_resp_Flank_P.tStopRefresh)
    # the Routine "ITI_P" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "Flanker_Feedback_P"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_Flank_P.corr:
        msg = "Correct"
    else:
        msg = "Incorrect"
    text_flankP_feedback.setColor('white', colorSpace='rgb')
    text_flankP_feedback.setText(msg)
    # keep track of which components have finished
    Flanker_Feedback_PComponents = [text_flankP_feedback]
    for thisComponent in Flanker_Feedback_PComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Flanker_Feedback_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Flanker_Feedback_P"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Flanker_Feedback_PClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Flanker_Feedback_PClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_flankP_feedback* updates
        if text_flankP_feedback.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_flankP_feedback.frameNStart = frameN  # exact frame index
            text_flankP_feedback.tStart = t  # local t and not account for scr refresh
            text_flankP_feedback.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_flankP_feedback, 'tStartRefresh')  # time at next scr refresh
            text_flankP_feedback.setAutoDraw(True)
        if text_flankP_feedback.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_flankP_feedback.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_flankP_feedback.tStop = t  # not accounting for scr refresh
                text_flankP_feedback.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_flankP_feedback, 'tStopRefresh')  # time at next scr refresh
                text_flankP_feedback.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Flanker_Feedback_PComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Flanker_Feedback_P"-------
    for thisComponent in Flanker_Feedback_PComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    PracFlankLoop.addData('text_flankP_feedback.started', text_flankP_feedback.tStartRefresh)
    PracFlankLoop.addData('text_flankP_feedback.stopped', text_flankP_feedback.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'PracFlankLoop'

# get names of stimulus parameters
if PracFlankLoop.trialList in ([], [None], None):
    params = []
else:
    params = PracFlankLoop.trialList[0].keys()
# save data for this loop
PracFlankLoop.saveAsExcel(filename + '.xlsx', sheetName='PracFlankLoop',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])
PracFlankLoop.saveAsText(filename + 'PracFlankLoop.csv', delim=',',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])

# ------Prepare to start Routine "FS"-------
continueRoutine = True
# update component parameters for each repeat
FS1.reset()
FS1.marker.size = (.03, .03)
# keep track of which components have finished
FSComponents = [text_fs, FS1]
for thisComponent in FSComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FS"-------
while continueRoutine:
    # get current time
    t = FSClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FSClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fs* updates
    if text_fs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fs.frameNStart = frameN  # exact frame index
        text_fs.tStart = t  # local t and not account for scr refresh
        text_fs.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fs, 'tStartRefresh')  # time at next scr refresh
        text_fs.setAutoDraw(True)
    
    # *FS1* updates
    if FS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FS1.frameNStart = frameN  # exact frame index
        FS1.tStart = t  # local t and not account for scr refresh
        FS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FS1, 'tStartRefresh')  # time at next scr refresh
        FS1.setAutoDraw(True)
    
    # Check FS1 for response to end routine
    if FS1.getRating() is not None and FS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FS"-------
for thisComponent in FSComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fs.started', text_fs.tStartRefresh)
thisExp.addData('text_fs.stopped', text_fs.tStopRefresh)
thisExp.addData('FS1.response', FS1.getRating())
thisExp.addData('FS1.rt', FS1.getRT())
thisExp.addData('FS1.started', FS1.tStartRefresh)
thisExp.addData('FS1.stopped', FS1.tStopRefresh)
# the Routine "FS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FAS"-------
continueRoutine = True
# update component parameters for each repeat
FAS1.reset()
FAS1.marker.size = (.03, .03)
# keep track of which components have finished
FASComponents = [text_fas, FAS1]
for thisComponent in FASComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FAS"-------
while continueRoutine:
    # get current time
    t = FASClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FASClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fas* updates
    if text_fas.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fas.frameNStart = frameN  # exact frame index
        text_fas.tStart = t  # local t and not account for scr refresh
        text_fas.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fas, 'tStartRefresh')  # time at next scr refresh
        text_fas.setAutoDraw(True)
    
    # *FAS1* updates
    if FAS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FAS1.frameNStart = frameN  # exact frame index
        FAS1.tStart = t  # local t and not account for scr refresh
        FAS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FAS1, 'tStartRefresh')  # time at next scr refresh
        FAS1.setAutoDraw(True)
    
    # Check FAS1 for response to end routine
    if FAS1.getRating() is not None and FAS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FASComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FAS"-------
for thisComponent in FASComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fas.started', text_fas.tStartRefresh)
thisExp.addData('text_fas.stopped', text_fas.tStopRefresh)
thisExp.addData('FAS1.response', FAS1.getRating())
thisExp.addData('FAS1.rt', FAS1.getRT())
thisExp.addData('FAS1.started', FAS1.tStartRefresh)
thisExp.addData('FAS1.stopped', FAS1.tStopRefresh)
# the Routine "FAS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Instr_flanker_T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_InstrFT.keys = []
key_resp_InstrFT.rt = []
_key_resp_InstrFT_allKeys = []
# keep track of which components have finished
Instr_flanker_TComponents = [text_Instr_flankT, key_resp_InstrFT]
for thisComponent in Instr_flanker_TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instr_flanker_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instr_flanker_T"-------
while continueRoutine:
    # get current time
    t = Instr_flanker_TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instr_flanker_TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_Instr_flankT* updates
    if text_Instr_flankT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_Instr_flankT.frameNStart = frameN  # exact frame index
        text_Instr_flankT.tStart = t  # local t and not account for scr refresh
        text_Instr_flankT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_Instr_flankT, 'tStartRefresh')  # time at next scr refresh
        text_Instr_flankT.setAutoDraw(True)
    
    # *key_resp_InstrFT* updates
    waitOnFlip = False
    if key_resp_InstrFT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_InstrFT.frameNStart = frameN  # exact frame index
        key_resp_InstrFT.tStart = t  # local t and not account for scr refresh
        key_resp_InstrFT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_InstrFT, 'tStartRefresh')  # time at next scr refresh
        key_resp_InstrFT.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_InstrFT.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_InstrFT.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_InstrFT.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_InstrFT.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_InstrFT_allKeys.extend(theseKeys)
        if len(_key_resp_InstrFT_allKeys):
            key_resp_InstrFT.keys = _key_resp_InstrFT_allKeys[-1].name  # just the last key pressed
            key_resp_InstrFT.rt = _key_resp_InstrFT_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instr_flanker_TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instr_flanker_T"-------
for thisComponent in Instr_flanker_TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_Instr_flankT.started', text_Instr_flankT.tStartRefresh)
thisExp.addData('text_Instr_flankT.stopped', text_Instr_flankT.tStopRefresh)
# check responses
if key_resp_InstrFT.keys in ['', [], None]:  # No response was made
    key_resp_InstrFT.keys = None
thisExp.addData('key_resp_InstrFT.keys',key_resp_InstrFT.keys)
if key_resp_InstrFT.keys != None:  # we had a response
    thisExp.addData('key_resp_InstrFT.rt', key_resp_InstrFT.rt)
thisExp.addData('key_resp_InstrFT.started', key_resp_InstrFT.tStartRefresh)
thisExp.addData('key_resp_InstrFT.stopped', key_resp_InstrFT.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instr_flanker_T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
BlockFlankLoop = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Files/FlankBlockList.xlsx'),
    seed=None, name='BlockFlankLoop')
thisExp.addLoop(BlockFlankLoop)  # add the loop to the experiment
thisBlockFlankLoop = BlockFlankLoop.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisBlockFlankLoop.rgb)
if thisBlockFlankLoop != None:
    for paramName in thisBlockFlankLoop:
        exec('{} = thisBlockFlankLoop[paramName]'.format(paramName))

for thisBlockFlankLoop in BlockFlankLoop:
    currentLoop = BlockFlankLoop
    # abbreviate parameter names if possible (e.g. rgb = thisBlockFlankLoop.rgb)
    if thisBlockFlankLoop != None:
        for paramName in thisBlockFlankLoop:
            exec('{} = thisBlockFlankLoop[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "InstructionBlock"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_Block1.keys = []
    key_resp_Block1.rt = []
    _key_resp_Block1_allKeys = []
    # keep track of which components have finished
    InstructionBlockComponents = [textInstrBlock1, key_resp_Block1]
    for thisComponent in InstructionBlockComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    InstructionBlockClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "InstructionBlock"-------
    while continueRoutine:
        # get current time
        t = InstructionBlockClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=InstructionBlockClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *textInstrBlock1* updates
        if textInstrBlock1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textInstrBlock1.frameNStart = frameN  # exact frame index
            textInstrBlock1.tStart = t  # local t and not account for scr refresh
            textInstrBlock1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textInstrBlock1, 'tStartRefresh')  # time at next scr refresh
            textInstrBlock1.setAutoDraw(True)
        
        # *key_resp_Block1* updates
        waitOnFlip = False
        if key_resp_Block1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_Block1.frameNStart = frameN  # exact frame index
            key_resp_Block1.tStart = t  # local t and not account for scr refresh
            key_resp_Block1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_Block1, 'tStartRefresh')  # time at next scr refresh
            key_resp_Block1.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_Block1.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_Block1.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_Block1.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_Block1.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_Block1_allKeys.extend(theseKeys)
            if len(_key_resp_Block1_allKeys):
                key_resp_Block1.keys = _key_resp_Block1_allKeys[-1].name  # just the last key pressed
                key_resp_Block1.rt = _key_resp_Block1_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in InstructionBlockComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "InstructionBlock"-------
    for thisComponent in InstructionBlockComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockFlankLoop.addData('textInstrBlock1.started', textInstrBlock1.tStartRefresh)
    BlockFlankLoop.addData('textInstrBlock1.stopped', textInstrBlock1.tStopRefresh)
    # check responses
    if key_resp_Block1.keys in ['', [], None]:  # No response was made
        key_resp_Block1.keys = None
    BlockFlankLoop.addData('key_resp_Block1.keys',key_resp_Block1.keys)
    if key_resp_Block1.keys != None:  # we had a response
        BlockFlankLoop.addData('key_resp_Block1.rt', key_resp_Block1.rt)
    BlockFlankLoop.addData('key_resp_Block1.started', key_resp_Block1.tStartRefresh)
    BlockFlankLoop.addData('key_resp_Block1.stopped', key_resp_Block1.tStopRefresh)
    # the Routine "InstructionBlock" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    TestFlankLoop = data.TrialHandler(nReps=1.0, method='fullRandom', 
        extraInfo=expInfo, originPath=-1,
        trialList=data.importConditions(Block),
        seed=None, name='TestFlankLoop')
    thisExp.addLoop(TestFlankLoop)  # add the loop to the experiment
    thisTestFlankLoop = TestFlankLoop.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTestFlankLoop.rgb)
    if thisTestFlankLoop != None:
        for paramName in thisTestFlankLoop:
            exec('{} = thisTestFlankLoop[paramName]'.format(paramName))
    
    for thisTestFlankLoop in TestFlankLoop:
        currentLoop = TestFlankLoop
        # abbreviate parameter names if possible (e.g. rgb = thisTestFlankLoop.rgb)
        if thisTestFlankLoop != None:
            for paramName in thisTestFlankLoop:
                exec('{} = thisTestFlankLoop[paramName]'.format(paramName))
        
        # ------Prepare to start Routine "fixation"-------
        continueRoutine = True
        routineTimer.add(0.500000)
        # update component parameters for each repeat
        # keep track of which components have finished
        fixationComponents = [textFix]
        for thisComponent in fixationComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        fixationClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "fixation"-------
        while continueRoutine and routineTimer.getTime() > 0:
            # get current time
            t = fixationClock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=fixationClock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *textFix* updates
            if textFix.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                textFix.frameNStart = frameN  # exact frame index
                textFix.tStart = t  # local t and not account for scr refresh
                textFix.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(textFix, 'tStartRefresh')  # time at next scr refresh
                textFix.setAutoDraw(True)
            if textFix.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > textFix.tStartRefresh + 0.5-frameTolerance:
                    # keep track of stop time/frame for later
                    textFix.tStop = t  # not accounting for scr refresh
                    textFix.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(textFix, 'tStopRefresh')  # time at next scr refresh
                    textFix.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in fixationComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "fixation"-------
        for thisComponent in fixationComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        TestFlankLoop.addData('textFix.started', textFix.tStartRefresh)
        TestFlankLoop.addData('textFix.stopped', textFix.tStopRefresh)
        
        # ------Prepare to start Routine "Flanker_T"-------
        continueRoutine = True
        routineTimer.add(0.100000)
        # update component parameters for each repeat
        textFlankerTest.setText(Stimulus)
        # keep track of which components have finished
        Flanker_TComponents = [textFlankerTest]
        for thisComponent in Flanker_TComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        Flanker_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "Flanker_T"-------
        while continueRoutine and routineTimer.getTime() > 0:
            # get current time
            t = Flanker_TClock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=Flanker_TClock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *textFlankerTest* updates
            if textFlankerTest.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                textFlankerTest.frameNStart = frameN  # exact frame index
                textFlankerTest.tStart = t  # local t and not account for scr refresh
                textFlankerTest.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(textFlankerTest, 'tStartRefresh')  # time at next scr refresh
                textFlankerTest.setAutoDraw(True)
            if textFlankerTest.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > textFlankerTest.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    textFlankerTest.tStop = t  # not accounting for scr refresh
                    textFlankerTest.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(textFlankerTest, 'tStopRefresh')  # time at next scr refresh
                    textFlankerTest.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in Flanker_TComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "Flanker_T"-------
        for thisComponent in Flanker_TComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        TestFlankLoop.addData('textFlankerTest.started', textFlankerTest.tStartRefresh)
        TestFlankLoop.addData('textFlankerTest.stopped', textFlankerTest.tStopRefresh)
        
        # ------Prepare to start Routine "ITI_T"-------
        continueRoutine = True
        # update component parameters for each repeat
        textITI_T.setText('')
        key_resp_Flank_T.keys = []
        key_resp_Flank_T.rt = []
        _key_resp_Flank_T_allKeys = []
        # keep track of which components have finished
        ITI_TComponents = [textITI_T, key_resp_Flank_T]
        for thisComponent in ITI_TComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        ITI_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "ITI_T"-------
        while continueRoutine:
            # get current time
            t = ITI_TClock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=ITI_TClock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *textITI_T* updates
            if textITI_T.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                textITI_T.frameNStart = frameN  # exact frame index
                textITI_T.tStart = t  # local t and not account for scr refresh
                textITI_T.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(textITI_T, 'tStartRefresh')  # time at next scr refresh
                textITI_T.setAutoDraw(True)
            if textITI_T.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > textITI_T.tStartRefresh + ITI-frameTolerance:
                    # keep track of stop time/frame for later
                    textITI_T.tStop = t  # not accounting for scr refresh
                    textITI_T.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(textITI_T, 'tStopRefresh')  # time at next scr refresh
                    textITI_T.setAutoDraw(False)
            
            # *key_resp_Flank_T* updates
            waitOnFlip = False
            if key_resp_Flank_T.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_Flank_T.frameNStart = frameN  # exact frame index
                key_resp_Flank_T.tStart = t  # local t and not account for scr refresh
                key_resp_Flank_T.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_Flank_T, 'tStartRefresh')  # time at next scr refresh
                key_resp_Flank_T.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_Flank_T.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_Flank_T.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_Flank_T.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > key_resp_Flank_T.tStartRefresh + ITI-frameTolerance:
                    # keep track of stop time/frame for later
                    key_resp_Flank_T.tStop = t  # not accounting for scr refresh
                    key_resp_Flank_T.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(key_resp_Flank_T, 'tStopRefresh')  # time at next scr refresh
                    key_resp_Flank_T.status = FINISHED
            if key_resp_Flank_T.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_Flank_T.getKeys(keyList=['a', 'l'], waitRelease=False)
                _key_resp_Flank_T_allKeys.extend(theseKeys)
                if len(_key_resp_Flank_T_allKeys):
                    key_resp_Flank_T.keys = _key_resp_Flank_T_allKeys[0].name  # just the first key pressed
                    key_resp_Flank_T.rt = _key_resp_Flank_T_allKeys[0].rt
                    # was this correct?
                    if (key_resp_Flank_T.keys == str(CorrectResp)) or (key_resp_Flank_T.keys == CorrectResp):
                        key_resp_Flank_T.corr = 1
                    else:
                        key_resp_Flank_T.corr = 0
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in ITI_TComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "ITI_T"-------
        for thisComponent in ITI_TComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        TestFlankLoop.addData('textITI_T.started', textITI_T.tStartRefresh)
        TestFlankLoop.addData('textITI_T.stopped', textITI_T.tStopRefresh)
        # check responses
        if key_resp_Flank_T.keys in ['', [], None]:  # No response was made
            key_resp_Flank_T.keys = None
            # was no response the correct answer?!
            if str(CorrectResp).lower() == 'none':
               key_resp_Flank_T.corr = 1;  # correct non-response
            else:
               key_resp_Flank_T.corr = 0;  # failed to respond (incorrectly)
        # store data for TestFlankLoop (TrialHandler)
        TestFlankLoop.addData('key_resp_Flank_T.keys',key_resp_Flank_T.keys)
        TestFlankLoop.addData('key_resp_Flank_T.corr', key_resp_Flank_T.corr)
        if key_resp_Flank_T.keys != None:  # we had a response
            TestFlankLoop.addData('key_resp_Flank_T.rt', key_resp_Flank_T.rt)
        TestFlankLoop.addData('key_resp_Flank_T.started', key_resp_Flank_T.tStartRefresh)
        TestFlankLoop.addData('key_resp_Flank_T.stopped', key_resp_Flank_T.tStopRefresh)
        # the Routine "ITI_T" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'TestFlankLoop'
    
    # get names of stimulus parameters
    if TestFlankLoop.trialList in ([], [None], None):
        params = []
    else:
        params = TestFlankLoop.trialList[0].keys()
    # save data for this loop
    TestFlankLoop.saveAsExcel(filename + '.xlsx', sheetName='TestFlankLoop',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    TestFlankLoop.saveAsText(filename + 'TestFlankLoop.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # ------Prepare to start Routine "BlockTxt"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blockfb.keys = []
    key_resp_blockfb.rt = []
    _key_resp_blockfb_allKeys = []
    # keep track of which components have finished
    BlockTxtComponents = [text_block, key_resp_blockfb]
    for thisComponent in BlockTxtComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    BlockTxtClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "BlockTxt"-------
    while continueRoutine:
        # get current time
        t = BlockTxtClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=BlockTxtClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_block* updates
        if text_block.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_block.frameNStart = frameN  # exact frame index
            text_block.tStart = t  # local t and not account for scr refresh
            text_block.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_block, 'tStartRefresh')  # time at next scr refresh
            text_block.setAutoDraw(True)
        
        # *key_resp_blockfb* updates
        waitOnFlip = False
        if key_resp_blockfb.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blockfb.frameNStart = frameN  # exact frame index
            key_resp_blockfb.tStart = t  # local t and not account for scr refresh
            key_resp_blockfb.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blockfb, 'tStartRefresh')  # time at next scr refresh
            key_resp_blockfb.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blockfb.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_blockfb.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_blockfb.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blockfb.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_blockfb_allKeys.extend(theseKeys)
            if len(_key_resp_blockfb_allKeys):
                key_resp_blockfb.keys = _key_resp_blockfb_allKeys[0].name  # just the first key pressed
                key_resp_blockfb.rt = _key_resp_blockfb_allKeys[0].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in BlockTxtComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "BlockTxt"-------
    for thisComponent in BlockTxtComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockFlankLoop.addData('text_block.started', text_block.tStartRefresh)
    BlockFlankLoop.addData('text_block.stopped', text_block.tStopRefresh)
    # check responses
    if key_resp_blockfb.keys in ['', [], None]:  # No response was made
        key_resp_blockfb.keys = None
    BlockFlankLoop.addData('key_resp_blockfb.keys',key_resp_blockfb.keys)
    if key_resp_blockfb.keys != None:  # we had a response
        BlockFlankLoop.addData('key_resp_blockfb.rt', key_resp_blockfb.rt)
    BlockFlankLoop.addData('key_resp_blockfb.started', key_resp_blockfb.tStartRefresh)
    BlockFlankLoop.addData('key_resp_blockfb.stopped', key_resp_blockfb.tStopRefresh)
    # the Routine "BlockTxt" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "FS"-------
    continueRoutine = True
    # update component parameters for each repeat
    FS1.reset()
    FS1.marker.size = (.03, .03)
    # keep track of which components have finished
    FSComponents = [text_fs, FS1]
    for thisComponent in FSComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "FS"-------
    while continueRoutine:
        # get current time
        t = FSClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=FSClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_fs* updates
        if text_fs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_fs.frameNStart = frameN  # exact frame index
            text_fs.tStart = t  # local t and not account for scr refresh
            text_fs.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_fs, 'tStartRefresh')  # time at next scr refresh
            text_fs.setAutoDraw(True)
        
        # *FS1* updates
        if FS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            FS1.frameNStart = frameN  # exact frame index
            FS1.tStart = t  # local t and not account for scr refresh
            FS1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(FS1, 'tStartRefresh')  # time at next scr refresh
            FS1.setAutoDraw(True)
        
        # Check FS1 for response to end routine
        if FS1.getRating() is not None and FS1.status == STARTED:
            continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in FSComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "FS"-------
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockFlankLoop.addData('text_fs.started', text_fs.tStartRefresh)
    BlockFlankLoop.addData('text_fs.stopped', text_fs.tStopRefresh)
    BlockFlankLoop.addData('FS1.response', FS1.getRating())
    BlockFlankLoop.addData('FS1.rt', FS1.getRT())
    BlockFlankLoop.addData('FS1.started', FS1.tStartRefresh)
    BlockFlankLoop.addData('FS1.stopped', FS1.tStopRefresh)
    # the Routine "FS" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "FAS"-------
    continueRoutine = True
    # update component parameters for each repeat
    FAS1.reset()
    FAS1.marker.size = (.03, .03)
    # keep track of which components have finished
    FASComponents = [text_fas, FAS1]
    for thisComponent in FASComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    FASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "FAS"-------
    while continueRoutine:
        # get current time
        t = FASClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=FASClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_fas* updates
        if text_fas.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_fas.frameNStart = frameN  # exact frame index
            text_fas.tStart = t  # local t and not account for scr refresh
            text_fas.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_fas, 'tStartRefresh')  # time at next scr refresh
            text_fas.setAutoDraw(True)
        
        # *FAS1* updates
        if FAS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            FAS1.frameNStart = frameN  # exact frame index
            FAS1.tStart = t  # local t and not account for scr refresh
            FAS1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(FAS1, 'tStartRefresh')  # time at next scr refresh
            FAS1.setAutoDraw(True)
        
        # Check FAS1 for response to end routine
        if FAS1.getRating() is not None and FAS1.status == STARTED:
            continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in FASComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "FAS"-------
    for thisComponent in FASComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockFlankLoop.addData('text_fas.started', text_fas.tStartRefresh)
    BlockFlankLoop.addData('text_fas.stopped', text_fas.tStopRefresh)
    BlockFlankLoop.addData('FAS1.response', FAS1.getRating())
    BlockFlankLoop.addData('FAS1.rt', FAS1.getRT())
    BlockFlankLoop.addData('FAS1.started', FAS1.tStartRefresh)
    BlockFlankLoop.addData('FAS1.stopped', FAS1.tStopRefresh)
    # the Routine "FAS" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'BlockFlankLoop'

# get names of stimulus parameters
if BlockFlankLoop.trialList in ([], [None], None):
    params = []
else:
    params = BlockFlankLoop.trialList[0].keys()
# save data for this loop
BlockFlankLoop.saveAsExcel(filename + '.xlsx', sheetName='BlockFlankLoop',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])
BlockFlankLoop.saveAsText(filename + 'BlockFlankLoop.csv', delim=',',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])

# ------Prepare to start Routine "Nback"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_2back.keys = []
key_resp_2back.rt = []
_key_resp_2back_allKeys = []
# keep track of which components have finished
NbackComponents = [text_2back, key_resp_2back]
for thisComponent in NbackComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
NbackClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Nback"-------
while continueRoutine:
    # get current time
    t = NbackClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=NbackClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_2back* updates
    if text_2back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_2back.frameNStart = frameN  # exact frame index
        text_2back.tStart = t  # local t and not account for scr refresh
        text_2back.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_2back, 'tStartRefresh')  # time at next scr refresh
        text_2back.setAutoDraw(True)
    
    # *key_resp_2back* updates
    waitOnFlip = False
    if key_resp_2back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_2back.frameNStart = frameN  # exact frame index
        key_resp_2back.tStart = t  # local t and not account for scr refresh
        key_resp_2back.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_2back, 'tStartRefresh')  # time at next scr refresh
        key_resp_2back.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_2back.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_2back.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_2back.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_2back.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_2back_allKeys.extend(theseKeys)
        if len(_key_resp_2back_allKeys):
            key_resp_2back.keys = _key_resp_2back_allKeys[-1].name  # just the last key pressed
            key_resp_2back.rt = _key_resp_2back_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in NbackComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Nback"-------
for thisComponent in NbackComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_2back.started', text_2back.tStartRefresh)
thisExp.addData('text_2back.stopped', text_2back.tStopRefresh)
# check responses
if key_resp_2back.keys in ['', [], None]:  # No response was made
    key_resp_2back.keys = None
thisExp.addData('key_resp_2back.keys',key_resp_2back.keys)
if key_resp_2back.keys != None:  # we had a response
    thisExp.addData('key_resp_2back.rt', key_resp_2back.rt)
thisExp.addData('key_resp_2back.started', key_resp_2back.tStartRefresh)
thisExp.addData('key_resp_2back.stopped', key_resp_2back.tStopRefresh)
thisExp.nextEntry()
# the Routine "Nback" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Instr_2back_P"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_2P.keys = []
key_resp_2P.rt = []
_key_resp_2P_allKeys = []
# keep track of which components have finished
Instr_2back_PComponents = [text_2backP, key_resp_2P]
for thisComponent in Instr_2back_PComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instr_2back_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instr_2back_P"-------
while continueRoutine:
    # get current time
    t = Instr_2back_PClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instr_2back_PClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_2backP* updates
    if text_2backP.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_2backP.frameNStart = frameN  # exact frame index
        text_2backP.tStart = t  # local t and not account for scr refresh
        text_2backP.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_2backP, 'tStartRefresh')  # time at next scr refresh
        text_2backP.setAutoDraw(True)
    
    # *key_resp_2P* updates
    waitOnFlip = False
    if key_resp_2P.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_2P.frameNStart = frameN  # exact frame index
        key_resp_2P.tStart = t  # local t and not account for scr refresh
        key_resp_2P.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_2P, 'tStartRefresh')  # time at next scr refresh
        key_resp_2P.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_2P.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_2P.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_2P.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_2P.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_2P_allKeys.extend(theseKeys)
        if len(_key_resp_2P_allKeys):
            key_resp_2P.keys = _key_resp_2P_allKeys[-1].name  # just the last key pressed
            key_resp_2P.rt = _key_resp_2P_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instr_2back_PComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instr_2back_P"-------
for thisComponent in Instr_2back_PComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_2backP.started', text_2backP.tStartRefresh)
thisExp.addData('text_2backP.stopped', text_2backP.tStopRefresh)
# check responses
if key_resp_2P.keys in ['', [], None]:  # No response was made
    key_resp_2P.keys = None
thisExp.addData('key_resp_2P.keys',key_resp_2P.keys)
if key_resp_2P.keys != None:  # we had a response
    thisExp.addData('key_resp_2P.rt', key_resp_2P.rt)
thisExp.addData('key_resp_2P.started', key_resp_2P.tStartRefresh)
thisExp.addData('key_resp_2P.stopped', key_resp_2P.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instr_2back_P" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Prac2backLoop = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Files/nback_2p.xlsx'),
    seed=None, name='Prac2backLoop')
thisExp.addLoop(Prac2backLoop)  # add the loop to the experiment
thisPrac2backLoop = Prac2backLoop.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPrac2backLoop.rgb)
if thisPrac2backLoop != None:
    for paramName in thisPrac2backLoop:
        exec('{} = thisPrac2backLoop[paramName]'.format(paramName))

for thisPrac2backLoop in Prac2backLoop:
    currentLoop = Prac2backLoop
    # abbreviate parameter names if possible (e.g. rgb = thisPrac2backLoop.rgb)
    if thisPrac2backLoop != None:
        for paramName in thisPrac2backLoop:
            exec('{} = thisPrac2backLoop[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "Nback2_P"-------
    continueRoutine = True
    routineTimer.add(1.500000)
    # update component parameters for each repeat
    stim_pract_2back.setText(letter)
    key_resp_2backP.keys = []
    key_resp_2backP.rt = []
    _key_resp_2backP_allKeys = []
    # keep track of which components have finished
    Nback2_PComponents = [stim_pract_2back, key_resp_2backP]
    for thisComponent in Nback2_PComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Nback2_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Nback2_P"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Nback2_PClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Nback2_PClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *stim_pract_2back* updates
        if stim_pract_2back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            stim_pract_2back.frameNStart = frameN  # exact frame index
            stim_pract_2back.tStart = t  # local t and not account for scr refresh
            stim_pract_2back.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(stim_pract_2back, 'tStartRefresh')  # time at next scr refresh
            stim_pract_2back.setAutoDraw(True)
        if stim_pract_2back.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > stim_pract_2back.tStartRefresh + 0.5-frameTolerance:
                # keep track of stop time/frame for later
                stim_pract_2back.tStop = t  # not accounting for scr refresh
                stim_pract_2back.frameNStop = frameN  # exact frame index
                win.timeOnFlip(stim_pract_2back, 'tStopRefresh')  # time at next scr refresh
                stim_pract_2back.setAutoDraw(False)
        
        # *key_resp_2backP* updates
        waitOnFlip = False
        if key_resp_2backP.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_2backP.frameNStart = frameN  # exact frame index
            key_resp_2backP.tStart = t  # local t and not account for scr refresh
            key_resp_2backP.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_2backP, 'tStartRefresh')  # time at next scr refresh
            key_resp_2backP.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_2backP.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_2backP.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_2backP.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_2backP.tStartRefresh + 1.5-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_2backP.tStop = t  # not accounting for scr refresh
                key_resp_2backP.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_2backP, 'tStopRefresh')  # time at next scr refresh
                key_resp_2backP.status = FINISHED
        if key_resp_2backP.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_2backP.getKeys(keyList=['a', 'l'], waitRelease=False)
            _key_resp_2backP_allKeys.extend(theseKeys)
            if len(_key_resp_2backP_allKeys):
                key_resp_2backP.keys = _key_resp_2backP_allKeys[0].name  # just the first key pressed
                key_resp_2backP.rt = _key_resp_2backP_allKeys[0].rt
                # was this correct?
                if (key_resp_2backP.keys == str(corrAns)) or (key_resp_2backP.keys == corrAns):
                    key_resp_2backP.corr = 1
                else:
                    key_resp_2backP.corr = 0
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Nback2_PComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Nback2_P"-------
    for thisComponent in Nback2_PComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Prac2backLoop.addData('stim_pract_2back.started', stim_pract_2back.tStartRefresh)
    Prac2backLoop.addData('stim_pract_2back.stopped', stim_pract_2back.tStopRefresh)
    # check responses
    if key_resp_2backP.keys in ['', [], None]:  # No response was made
        key_resp_2backP.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_2backP.corr = 1;  # correct non-response
        else:
           key_resp_2backP.corr = 0;  # failed to respond (incorrectly)
    # store data for Prac2backLoop (TrialHandler)
    Prac2backLoop.addData('key_resp_2backP.keys',key_resp_2backP.keys)
    Prac2backLoop.addData('key_resp_2backP.corr', key_resp_2backP.corr)
    if key_resp_2backP.keys != None:  # we had a response
        Prac2backLoop.addData('key_resp_2backP.rt', key_resp_2backP.rt)
    Prac2backLoop.addData('key_resp_2backP.started', key_resp_2backP.tStartRefresh)
    Prac2backLoop.addData('key_resp_2backP.stopped', key_resp_2backP.tStopRefresh)
    
    # ------Prepare to start Routine "Nback2_FeedbackP"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_2backP.corr:
        msg1 = "Correct"
    else:
        msg1 = "Incorrect"
    text_feedback2back.setText(msg1)
    # keep track of which components have finished
    Nback2_FeedbackPComponents = [text_feedback2back]
    for thisComponent in Nback2_FeedbackPComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Nback2_FeedbackPClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Nback2_FeedbackP"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Nback2_FeedbackPClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Nback2_FeedbackPClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_feedback2back* updates
        if text_feedback2back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_feedback2back.frameNStart = frameN  # exact frame index
            text_feedback2back.tStart = t  # local t and not account for scr refresh
            text_feedback2back.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_feedback2back, 'tStartRefresh')  # time at next scr refresh
            text_feedback2back.setAutoDraw(True)
        if text_feedback2back.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_feedback2back.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_feedback2back.tStop = t  # not accounting for scr refresh
                text_feedback2back.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_feedback2back, 'tStopRefresh')  # time at next scr refresh
                text_feedback2back.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Nback2_FeedbackPComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Nback2_FeedbackP"-------
    for thisComponent in Nback2_FeedbackPComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Prac2backLoop.addData('text_feedback2back.started', text_feedback2back.tStartRefresh)
    Prac2backLoop.addData('text_feedback2back.stopped', text_feedback2back.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'Prac2backLoop'

# get names of stimulus parameters
if Prac2backLoop.trialList in ([], [None], None):
    params = []
else:
    params = Prac2backLoop.trialList[0].keys()
# save data for this loop
Prac2backLoop.saveAsExcel(filename + '.xlsx', sheetName='Prac2backLoop',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])
Prac2backLoop.saveAsText(filename + 'Prac2backLoop.csv', delim=',',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])

# ------Prepare to start Routine "FS"-------
continueRoutine = True
# update component parameters for each repeat
FS1.reset()
FS1.marker.size = (.03, .03)
# keep track of which components have finished
FSComponents = [text_fs, FS1]
for thisComponent in FSComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FS"-------
while continueRoutine:
    # get current time
    t = FSClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FSClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fs* updates
    if text_fs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fs.frameNStart = frameN  # exact frame index
        text_fs.tStart = t  # local t and not account for scr refresh
        text_fs.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fs, 'tStartRefresh')  # time at next scr refresh
        text_fs.setAutoDraw(True)
    
    # *FS1* updates
    if FS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FS1.frameNStart = frameN  # exact frame index
        FS1.tStart = t  # local t and not account for scr refresh
        FS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FS1, 'tStartRefresh')  # time at next scr refresh
        FS1.setAutoDraw(True)
    
    # Check FS1 for response to end routine
    if FS1.getRating() is not None and FS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FS"-------
for thisComponent in FSComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fs.started', text_fs.tStartRefresh)
thisExp.addData('text_fs.stopped', text_fs.tStopRefresh)
thisExp.addData('FS1.response', FS1.getRating())
thisExp.addData('FS1.rt', FS1.getRT())
thisExp.addData('FS1.started', FS1.tStartRefresh)
thisExp.addData('FS1.stopped', FS1.tStopRefresh)
# the Routine "FS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FAS"-------
continueRoutine = True
# update component parameters for each repeat
FAS1.reset()
FAS1.marker.size = (.03, .03)
# keep track of which components have finished
FASComponents = [text_fas, FAS1]
for thisComponent in FASComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FAS"-------
while continueRoutine:
    # get current time
    t = FASClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FASClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fas* updates
    if text_fas.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fas.frameNStart = frameN  # exact frame index
        text_fas.tStart = t  # local t and not account for scr refresh
        text_fas.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fas, 'tStartRefresh')  # time at next scr refresh
        text_fas.setAutoDraw(True)
    
    # *FAS1* updates
    if FAS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FAS1.frameNStart = frameN  # exact frame index
        FAS1.tStart = t  # local t and not account for scr refresh
        FAS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FAS1, 'tStartRefresh')  # time at next scr refresh
        FAS1.setAutoDraw(True)
    
    # Check FAS1 for response to end routine
    if FAS1.getRating() is not None and FAS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FASComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FAS"-------
for thisComponent in FASComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fas.started', text_fas.tStartRefresh)
thisExp.addData('text_fas.stopped', text_fas.tStopRefresh)
thisExp.addData('FAS1.response', FAS1.getRating())
thisExp.addData('FAS1.rt', FAS1.getRT())
thisExp.addData('FAS1.started', FAS1.tStartRefresh)
thisExp.addData('FAS1.stopped', FAS1.tStopRefresh)
# the Routine "FAS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Instr_2back_T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_2.keys = []
key_resp_2.rt = []
_key_resp_2_allKeys = []
# keep track of which components have finished
Instr_2back_TComponents = [text_2backT, key_resp_2]
for thisComponent in Instr_2back_TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instr_2back_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instr_2back_T"-------
while continueRoutine:
    # get current time
    t = Instr_2back_TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instr_2back_TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_2backT* updates
    if text_2backT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_2backT.frameNStart = frameN  # exact frame index
        text_2backT.tStart = t  # local t and not account for scr refresh
        text_2backT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_2backT, 'tStartRefresh')  # time at next scr refresh
        text_2backT.setAutoDraw(True)
    
    # *key_resp_2* updates
    waitOnFlip = False
    if key_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_2.frameNStart = frameN  # exact frame index
        key_resp_2.tStart = t  # local t and not account for scr refresh
        key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
        key_resp_2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_2.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_2.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_2_allKeys.extend(theseKeys)
        if len(_key_resp_2_allKeys):
            key_resp_2.keys = _key_resp_2_allKeys[-1].name  # just the last key pressed
            key_resp_2.rt = _key_resp_2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instr_2back_TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instr_2back_T"-------
for thisComponent in Instr_2back_TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_2backT.started', text_2backT.tStartRefresh)
thisExp.addData('text_2backT.stopped', text_2backT.tStopRefresh)
# check responses
if key_resp_2.keys in ['', [], None]:  # No response was made
    key_resp_2.keys = None
thisExp.addData('key_resp_2.keys',key_resp_2.keys)
if key_resp_2.keys != None:  # we had a response
    thisExp.addData('key_resp_2.rt', key_resp_2.rt)
thisExp.addData('key_resp_2.started', key_resp_2.tStartRefresh)
thisExp.addData('key_resp_2.stopped', key_resp_2.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instr_2back_T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
BlockTestNback2 = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Files/Nback2BlockList.xlsx'),
    seed=None, name='BlockTestNback2')
thisExp.addLoop(BlockTestNback2)  # add the loop to the experiment
thisBlockTestNback2 = BlockTestNback2.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisBlockTestNback2.rgb)
if thisBlockTestNback2 != None:
    for paramName in thisBlockTestNback2:
        exec('{} = thisBlockTestNback2[paramName]'.format(paramName))

for thisBlockTestNback2 in BlockTestNback2:
    currentLoop = BlockTestNback2
    # abbreviate parameter names if possible (e.g. rgb = thisBlockTestNback2.rgb)
    if thisBlockTestNback2 != None:
        for paramName in thisBlockTestNback2:
            exec('{} = thisBlockTestNback2[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "InstructionBlock"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_Block1.keys = []
    key_resp_Block1.rt = []
    _key_resp_Block1_allKeys = []
    # keep track of which components have finished
    InstructionBlockComponents = [textInstrBlock1, key_resp_Block1]
    for thisComponent in InstructionBlockComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    InstructionBlockClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "InstructionBlock"-------
    while continueRoutine:
        # get current time
        t = InstructionBlockClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=InstructionBlockClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *textInstrBlock1* updates
        if textInstrBlock1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textInstrBlock1.frameNStart = frameN  # exact frame index
            textInstrBlock1.tStart = t  # local t and not account for scr refresh
            textInstrBlock1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textInstrBlock1, 'tStartRefresh')  # time at next scr refresh
            textInstrBlock1.setAutoDraw(True)
        
        # *key_resp_Block1* updates
        waitOnFlip = False
        if key_resp_Block1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_Block1.frameNStart = frameN  # exact frame index
            key_resp_Block1.tStart = t  # local t and not account for scr refresh
            key_resp_Block1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_Block1, 'tStartRefresh')  # time at next scr refresh
            key_resp_Block1.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_Block1.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_Block1.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_Block1.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_Block1.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_Block1_allKeys.extend(theseKeys)
            if len(_key_resp_Block1_allKeys):
                key_resp_Block1.keys = _key_resp_Block1_allKeys[-1].name  # just the last key pressed
                key_resp_Block1.rt = _key_resp_Block1_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in InstructionBlockComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "InstructionBlock"-------
    for thisComponent in InstructionBlockComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback2.addData('textInstrBlock1.started', textInstrBlock1.tStartRefresh)
    BlockTestNback2.addData('textInstrBlock1.stopped', textInstrBlock1.tStopRefresh)
    # check responses
    if key_resp_Block1.keys in ['', [], None]:  # No response was made
        key_resp_Block1.keys = None
    BlockTestNback2.addData('key_resp_Block1.keys',key_resp_Block1.keys)
    if key_resp_Block1.keys != None:  # we had a response
        BlockTestNback2.addData('key_resp_Block1.rt', key_resp_Block1.rt)
    BlockTestNback2.addData('key_resp_Block1.started', key_resp_Block1.tStartRefresh)
    BlockTestNback2.addData('key_resp_Block1.stopped', key_resp_Block1.tStopRefresh)
    # the Routine "InstructionBlock" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    Test2backLoop = data.TrialHandler(nReps=1.0, method='sequential', 
        extraInfo=expInfo, originPath=-1,
        trialList=data.importConditions(Block),
        seed=None, name='Test2backLoop')
    thisExp.addLoop(Test2backLoop)  # add the loop to the experiment
    thisTest2backLoop = Test2backLoop.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTest2backLoop.rgb)
    if thisTest2backLoop != None:
        for paramName in thisTest2backLoop:
            exec('{} = thisTest2backLoop[paramName]'.format(paramName))
    
    for thisTest2backLoop in Test2backLoop:
        currentLoop = Test2backLoop
        # abbreviate parameter names if possible (e.g. rgb = thisTest2backLoop.rgb)
        if thisTest2backLoop != None:
            for paramName in thisTest2backLoop:
                exec('{} = thisTest2backLoop[paramName]'.format(paramName))
        
        # ------Prepare to start Routine "Nback2_T"-------
        continueRoutine = True
        routineTimer.add(1.500000)
        # update component parameters for each repeat
        stim_test_2back.setText(letter)
        key_resp_2backT.keys = []
        key_resp_2backT.rt = []
        _key_resp_2backT_allKeys = []
        # keep track of which components have finished
        Nback2_TComponents = [stim_test_2back, key_resp_2backT]
        for thisComponent in Nback2_TComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        Nback2_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "Nback2_T"-------
        while continueRoutine and routineTimer.getTime() > 0:
            # get current time
            t = Nback2_TClock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=Nback2_TClock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *stim_test_2back* updates
            if stim_test_2back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                stim_test_2back.frameNStart = frameN  # exact frame index
                stim_test_2back.tStart = t  # local t and not account for scr refresh
                stim_test_2back.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(stim_test_2back, 'tStartRefresh')  # time at next scr refresh
                stim_test_2back.setAutoDraw(True)
            if stim_test_2back.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > stim_test_2back.tStartRefresh + 0.5-frameTolerance:
                    # keep track of stop time/frame for later
                    stim_test_2back.tStop = t  # not accounting for scr refresh
                    stim_test_2back.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(stim_test_2back, 'tStopRefresh')  # time at next scr refresh
                    stim_test_2back.setAutoDraw(False)
            
            # *key_resp_2backT* updates
            waitOnFlip = False
            if key_resp_2backT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_2backT.frameNStart = frameN  # exact frame index
                key_resp_2backT.tStart = t  # local t and not account for scr refresh
                key_resp_2backT.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_2backT, 'tStartRefresh')  # time at next scr refresh
                key_resp_2backT.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_2backT.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_2backT.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_2backT.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > key_resp_2backT.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    key_resp_2backT.tStop = t  # not accounting for scr refresh
                    key_resp_2backT.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(key_resp_2backT, 'tStopRefresh')  # time at next scr refresh
                    key_resp_2backT.status = FINISHED
            if key_resp_2backT.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_2backT.getKeys(keyList=['a', 'l'], waitRelease=False)
                _key_resp_2backT_allKeys.extend(theseKeys)
                if len(_key_resp_2backT_allKeys):
                    key_resp_2backT.keys = _key_resp_2backT_allKeys[0].name  # just the first key pressed
                    key_resp_2backT.rt = _key_resp_2backT_allKeys[0].rt
                    # was this correct?
                    if (key_resp_2backT.keys == str(corrAns)) or (key_resp_2backT.keys == corrAns):
                        key_resp_2backT.corr = 1
                    else:
                        key_resp_2backT.corr = 0
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in Nback2_TComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "Nback2_T"-------
        for thisComponent in Nback2_TComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        Test2backLoop.addData('stim_test_2back.started', stim_test_2back.tStartRefresh)
        Test2backLoop.addData('stim_test_2back.stopped', stim_test_2back.tStopRefresh)
        # check responses
        if key_resp_2backT.keys in ['', [], None]:  # No response was made
            key_resp_2backT.keys = None
            # was no response the correct answer?!
            if str(corrAns).lower() == 'none':
               key_resp_2backT.corr = 1;  # correct non-response
            else:
               key_resp_2backT.corr = 0;  # failed to respond (incorrectly)
        # store data for Test2backLoop (TrialHandler)
        Test2backLoop.addData('key_resp_2backT.keys',key_resp_2backT.keys)
        Test2backLoop.addData('key_resp_2backT.corr', key_resp_2backT.corr)
        if key_resp_2backT.keys != None:  # we had a response
            Test2backLoop.addData('key_resp_2backT.rt', key_resp_2backT.rt)
        Test2backLoop.addData('key_resp_2backT.started', key_resp_2backT.tStartRefresh)
        Test2backLoop.addData('key_resp_2backT.stopped', key_resp_2backT.tStopRefresh)
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'Test2backLoop'
    
    # get names of stimulus parameters
    if Test2backLoop.trialList in ([], [None], None):
        params = []
    else:
        params = Test2backLoop.trialList[0].keys()
    # save data for this loop
    Test2backLoop.saveAsExcel(filename + '.xlsx', sheetName='Test2backLoop',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    Test2backLoop.saveAsText(filename + 'Test2backLoop.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # ------Prepare to start Routine "BlockTxt"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blockfb.keys = []
    key_resp_blockfb.rt = []
    _key_resp_blockfb_allKeys = []
    # keep track of which components have finished
    BlockTxtComponents = [text_block, key_resp_blockfb]
    for thisComponent in BlockTxtComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    BlockTxtClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "BlockTxt"-------
    while continueRoutine:
        # get current time
        t = BlockTxtClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=BlockTxtClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_block* updates
        if text_block.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_block.frameNStart = frameN  # exact frame index
            text_block.tStart = t  # local t and not account for scr refresh
            text_block.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_block, 'tStartRefresh')  # time at next scr refresh
            text_block.setAutoDraw(True)
        
        # *key_resp_blockfb* updates
        waitOnFlip = False
        if key_resp_blockfb.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blockfb.frameNStart = frameN  # exact frame index
            key_resp_blockfb.tStart = t  # local t and not account for scr refresh
            key_resp_blockfb.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blockfb, 'tStartRefresh')  # time at next scr refresh
            key_resp_blockfb.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blockfb.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_blockfb.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_blockfb.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blockfb.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_blockfb_allKeys.extend(theseKeys)
            if len(_key_resp_blockfb_allKeys):
                key_resp_blockfb.keys = _key_resp_blockfb_allKeys[0].name  # just the first key pressed
                key_resp_blockfb.rt = _key_resp_blockfb_allKeys[0].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in BlockTxtComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "BlockTxt"-------
    for thisComponent in BlockTxtComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback2.addData('text_block.started', text_block.tStartRefresh)
    BlockTestNback2.addData('text_block.stopped', text_block.tStopRefresh)
    # check responses
    if key_resp_blockfb.keys in ['', [], None]:  # No response was made
        key_resp_blockfb.keys = None
    BlockTestNback2.addData('key_resp_blockfb.keys',key_resp_blockfb.keys)
    if key_resp_blockfb.keys != None:  # we had a response
        BlockTestNback2.addData('key_resp_blockfb.rt', key_resp_blockfb.rt)
    BlockTestNback2.addData('key_resp_blockfb.started', key_resp_blockfb.tStartRefresh)
    BlockTestNback2.addData('key_resp_blockfb.stopped', key_resp_blockfb.tStopRefresh)
    # the Routine "BlockTxt" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "FS"-------
    continueRoutine = True
    # update component parameters for each repeat
    FS1.reset()
    FS1.marker.size = (.03, .03)
    # keep track of which components have finished
    FSComponents = [text_fs, FS1]
    for thisComponent in FSComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "FS"-------
    while continueRoutine:
        # get current time
        t = FSClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=FSClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_fs* updates
        if text_fs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_fs.frameNStart = frameN  # exact frame index
            text_fs.tStart = t  # local t and not account for scr refresh
            text_fs.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_fs, 'tStartRefresh')  # time at next scr refresh
            text_fs.setAutoDraw(True)
        
        # *FS1* updates
        if FS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            FS1.frameNStart = frameN  # exact frame index
            FS1.tStart = t  # local t and not account for scr refresh
            FS1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(FS1, 'tStartRefresh')  # time at next scr refresh
            FS1.setAutoDraw(True)
        
        # Check FS1 for response to end routine
        if FS1.getRating() is not None and FS1.status == STARTED:
            continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in FSComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "FS"-------
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback2.addData('text_fs.started', text_fs.tStartRefresh)
    BlockTestNback2.addData('text_fs.stopped', text_fs.tStopRefresh)
    BlockTestNback2.addData('FS1.response', FS1.getRating())
    BlockTestNback2.addData('FS1.rt', FS1.getRT())
    BlockTestNback2.addData('FS1.started', FS1.tStartRefresh)
    BlockTestNback2.addData('FS1.stopped', FS1.tStopRefresh)
    # the Routine "FS" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "FAS"-------
    continueRoutine = True
    # update component parameters for each repeat
    FAS1.reset()
    FAS1.marker.size = (.03, .03)
    # keep track of which components have finished
    FASComponents = [text_fas, FAS1]
    for thisComponent in FASComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    FASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "FAS"-------
    while continueRoutine:
        # get current time
        t = FASClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=FASClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_fas* updates
        if text_fas.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_fas.frameNStart = frameN  # exact frame index
            text_fas.tStart = t  # local t and not account for scr refresh
            text_fas.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_fas, 'tStartRefresh')  # time at next scr refresh
            text_fas.setAutoDraw(True)
        
        # *FAS1* updates
        if FAS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            FAS1.frameNStart = frameN  # exact frame index
            FAS1.tStart = t  # local t and not account for scr refresh
            FAS1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(FAS1, 'tStartRefresh')  # time at next scr refresh
            FAS1.setAutoDraw(True)
        
        # Check FAS1 for response to end routine
        if FAS1.getRating() is not None and FAS1.status == STARTED:
            continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in FASComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "FAS"-------
    for thisComponent in FASComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback2.addData('text_fas.started', text_fas.tStartRefresh)
    BlockTestNback2.addData('text_fas.stopped', text_fas.tStopRefresh)
    BlockTestNback2.addData('FAS1.response', FAS1.getRating())
    BlockTestNback2.addData('FAS1.rt', FAS1.getRT())
    BlockTestNback2.addData('FAS1.started', FAS1.tStartRefresh)
    BlockTestNback2.addData('FAS1.stopped', FAS1.tStopRefresh)
    # the Routine "FAS" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'BlockTestNback2'

# get names of stimulus parameters
if BlockTestNback2.trialList in ([], [None], None):
    params = []
else:
    params = BlockTestNback2.trialList[0].keys()
# save data for this loop
BlockTestNback2.saveAsExcel(filename + '.xlsx', sheetName='BlockTestNback2',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])
BlockTestNback2.saveAsText(filename + 'BlockTestNback2.csv', delim=',',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])

# ------Prepare to start Routine "Instr_3back_P"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_3P.keys = []
key_resp_3P.rt = []
_key_resp_3P_allKeys = []
# keep track of which components have finished
Instr_3back_PComponents = [text_3backP, key_resp_3P]
for thisComponent in Instr_3back_PComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instr_3back_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instr_3back_P"-------
while continueRoutine:
    # get current time
    t = Instr_3back_PClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instr_3back_PClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_3backP* updates
    if text_3backP.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_3backP.frameNStart = frameN  # exact frame index
        text_3backP.tStart = t  # local t and not account for scr refresh
        text_3backP.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_3backP, 'tStartRefresh')  # time at next scr refresh
        text_3backP.setAutoDraw(True)
    
    # *key_resp_3P* updates
    waitOnFlip = False
    if key_resp_3P.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_3P.frameNStart = frameN  # exact frame index
        key_resp_3P.tStart = t  # local t and not account for scr refresh
        key_resp_3P.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_3P, 'tStartRefresh')  # time at next scr refresh
        key_resp_3P.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_3P.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_3P.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_3P.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_3P.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_3P_allKeys.extend(theseKeys)
        if len(_key_resp_3P_allKeys):
            key_resp_3P.keys = _key_resp_3P_allKeys[-1].name  # just the last key pressed
            key_resp_3P.rt = _key_resp_3P_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instr_3back_PComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instr_3back_P"-------
for thisComponent in Instr_3back_PComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_3backP.started', text_3backP.tStartRefresh)
thisExp.addData('text_3backP.stopped', text_3backP.tStopRefresh)
# check responses
if key_resp_3P.keys in ['', [], None]:  # No response was made
    key_resp_3P.keys = None
thisExp.addData('key_resp_3P.keys',key_resp_3P.keys)
if key_resp_3P.keys != None:  # we had a response
    thisExp.addData('key_resp_3P.rt', key_resp_3P.rt)
thisExp.addData('key_resp_3P.started', key_resp_3P.tStartRefresh)
thisExp.addData('key_resp_3P.stopped', key_resp_3P.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instr_3back_P" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
Prac3backLoop = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Files/nback_3p.xlsx'),
    seed=None, name='Prac3backLoop')
thisExp.addLoop(Prac3backLoop)  # add the loop to the experiment
thisPrac3backLoop = Prac3backLoop.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisPrac3backLoop.rgb)
if thisPrac3backLoop != None:
    for paramName in thisPrac3backLoop:
        exec('{} = thisPrac3backLoop[paramName]'.format(paramName))

for thisPrac3backLoop in Prac3backLoop:
    currentLoop = Prac3backLoop
    # abbreviate parameter names if possible (e.g. rgb = thisPrac3backLoop.rgb)
    if thisPrac3backLoop != None:
        for paramName in thisPrac3backLoop:
            exec('{} = thisPrac3backLoop[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "Nback3_P"-------
    continueRoutine = True
    routineTimer.add(1.500000)
    # update component parameters for each repeat
    stim_pract_3back.setText(letter)
    key_resp_3backP.keys = []
    key_resp_3backP.rt = []
    _key_resp_3backP_allKeys = []
    # keep track of which components have finished
    Nback3_PComponents = [stim_pract_3back, key_resp_3backP]
    for thisComponent in Nback3_PComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Nback3_PClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Nback3_P"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Nback3_PClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Nback3_PClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *stim_pract_3back* updates
        if stim_pract_3back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            stim_pract_3back.frameNStart = frameN  # exact frame index
            stim_pract_3back.tStart = t  # local t and not account for scr refresh
            stim_pract_3back.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(stim_pract_3back, 'tStartRefresh')  # time at next scr refresh
            stim_pract_3back.setAutoDraw(True)
        if stim_pract_3back.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > stim_pract_3back.tStartRefresh + 0.5-frameTolerance:
                # keep track of stop time/frame for later
                stim_pract_3back.tStop = t  # not accounting for scr refresh
                stim_pract_3back.frameNStop = frameN  # exact frame index
                win.timeOnFlip(stim_pract_3back, 'tStopRefresh')  # time at next scr refresh
                stim_pract_3back.setAutoDraw(False)
        
        # *key_resp_3backP* updates
        waitOnFlip = False
        if key_resp_3backP.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_3backP.frameNStart = frameN  # exact frame index
            key_resp_3backP.tStart = t  # local t and not account for scr refresh
            key_resp_3backP.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_3backP, 'tStartRefresh')  # time at next scr refresh
            key_resp_3backP.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_3backP.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_3backP.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_3backP.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > key_resp_3backP.tStartRefresh + 1.5-frameTolerance:
                # keep track of stop time/frame for later
                key_resp_3backP.tStop = t  # not accounting for scr refresh
                key_resp_3backP.frameNStop = frameN  # exact frame index
                win.timeOnFlip(key_resp_3backP, 'tStopRefresh')  # time at next scr refresh
                key_resp_3backP.status = FINISHED
        if key_resp_3backP.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_3backP.getKeys(keyList=['a', 'l'], waitRelease=False)
            _key_resp_3backP_allKeys.extend(theseKeys)
            if len(_key_resp_3backP_allKeys):
                key_resp_3backP.keys = _key_resp_3backP_allKeys[0].name  # just the first key pressed
                key_resp_3backP.rt = _key_resp_3backP_allKeys[0].rt
                # was this correct?
                if (key_resp_3backP.keys == str(corrAns)) or (key_resp_3backP.keys == corrAns):
                    key_resp_3backP.corr = 1
                else:
                    key_resp_3backP.corr = 0
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Nback3_PComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Nback3_P"-------
    for thisComponent in Nback3_PComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Prac3backLoop.addData('stim_pract_3back.started', stim_pract_3back.tStartRefresh)
    Prac3backLoop.addData('stim_pract_3back.stopped', stim_pract_3back.tStopRefresh)
    # check responses
    if key_resp_3backP.keys in ['', [], None]:  # No response was made
        key_resp_3backP.keys = None
        # was no response the correct answer?!
        if str(corrAns).lower() == 'none':
           key_resp_3backP.corr = 1;  # correct non-response
        else:
           key_resp_3backP.corr = 0;  # failed to respond (incorrectly)
    # store data for Prac3backLoop (TrialHandler)
    Prac3backLoop.addData('key_resp_3backP.keys',key_resp_3backP.keys)
    Prac3backLoop.addData('key_resp_3backP.corr', key_resp_3backP.corr)
    if key_resp_3backP.keys != None:  # we had a response
        Prac3backLoop.addData('key_resp_3backP.rt', key_resp_3backP.rt)
    Prac3backLoop.addData('key_resp_3backP.started', key_resp_3backP.tStartRefresh)
    Prac3backLoop.addData('key_resp_3backP.stopped', key_resp_3backP.tStopRefresh)
    
    # ------Prepare to start Routine "Nback3_FeedbackP"-------
    continueRoutine = True
    routineTimer.add(1.000000)
    # update component parameters for each repeat
    if key_resp_3backP.corr:
        msg2 = "Correct"
    else:
        msg2 = "Incorrect"
    text_feedback3back.setText(msg2)
    # keep track of which components have finished
    Nback3_FeedbackPComponents = [text_feedback3back]
    for thisComponent in Nback3_FeedbackPComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    Nback3_FeedbackPClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "Nback3_FeedbackP"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = Nback3_FeedbackPClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=Nback3_FeedbackPClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_feedback3back* updates
        if text_feedback3back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_feedback3back.frameNStart = frameN  # exact frame index
            text_feedback3back.tStart = t  # local t and not account for scr refresh
            text_feedback3back.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_feedback3back, 'tStartRefresh')  # time at next scr refresh
            text_feedback3back.setAutoDraw(True)
        if text_feedback3back.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_feedback3back.tStartRefresh + 1.0-frameTolerance:
                # keep track of stop time/frame for later
                text_feedback3back.tStop = t  # not accounting for scr refresh
                text_feedback3back.frameNStop = frameN  # exact frame index
                win.timeOnFlip(text_feedback3back, 'tStopRefresh')  # time at next scr refresh
                text_feedback3back.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Nback3_FeedbackPComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "Nback3_FeedbackP"-------
    for thisComponent in Nback3_FeedbackPComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    Prac3backLoop.addData('text_feedback3back.started', text_feedback3back.tStartRefresh)
    Prac3backLoop.addData('text_feedback3back.stopped', text_feedback3back.tStopRefresh)
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'Prac3backLoop'

# get names of stimulus parameters
if Prac3backLoop.trialList in ([], [None], None):
    params = []
else:
    params = Prac3backLoop.trialList[0].keys()
# save data for this loop
Prac3backLoop.saveAsExcel(filename + '.xlsx', sheetName='Prac3backLoop',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])
Prac3backLoop.saveAsText(filename + 'Prac3backLoop.csv', delim=',',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])

# ------Prepare to start Routine "FS"-------
continueRoutine = True
# update component parameters for each repeat
FS1.reset()
FS1.marker.size = (.03, .03)
# keep track of which components have finished
FSComponents = [text_fs, FS1]
for thisComponent in FSComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FS"-------
while continueRoutine:
    # get current time
    t = FSClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FSClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fs* updates
    if text_fs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fs.frameNStart = frameN  # exact frame index
        text_fs.tStart = t  # local t and not account for scr refresh
        text_fs.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fs, 'tStartRefresh')  # time at next scr refresh
        text_fs.setAutoDraw(True)
    
    # *FS1* updates
    if FS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FS1.frameNStart = frameN  # exact frame index
        FS1.tStart = t  # local t and not account for scr refresh
        FS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FS1, 'tStartRefresh')  # time at next scr refresh
        FS1.setAutoDraw(True)
    
    # Check FS1 for response to end routine
    if FS1.getRating() is not None and FS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FS"-------
for thisComponent in FSComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fs.started', text_fs.tStartRefresh)
thisExp.addData('text_fs.stopped', text_fs.tStopRefresh)
thisExp.addData('FS1.response', FS1.getRating())
thisExp.addData('FS1.rt', FS1.getRT())
thisExp.addData('FS1.started', FS1.tStartRefresh)
thisExp.addData('FS1.stopped', FS1.tStopRefresh)
# the Routine "FS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "FAS"-------
continueRoutine = True
# update component parameters for each repeat
FAS1.reset()
FAS1.marker.size = (.03, .03)
# keep track of which components have finished
FASComponents = [text_fas, FAS1]
for thisComponent in FASComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "FAS"-------
while continueRoutine:
    # get current time
    t = FASClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=FASClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_fas* updates
    if text_fas.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_fas.frameNStart = frameN  # exact frame index
        text_fas.tStart = t  # local t and not account for scr refresh
        text_fas.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_fas, 'tStartRefresh')  # time at next scr refresh
        text_fas.setAutoDraw(True)
    
    # *FAS1* updates
    if FAS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        FAS1.frameNStart = frameN  # exact frame index
        FAS1.tStart = t  # local t and not account for scr refresh
        FAS1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(FAS1, 'tStartRefresh')  # time at next scr refresh
        FAS1.setAutoDraw(True)
    
    # Check FAS1 for response to end routine
    if FAS1.getRating() is not None and FAS1.status == STARTED:
        continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in FASComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "FAS"-------
for thisComponent in FASComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_fas.started', text_fas.tStartRefresh)
thisExp.addData('text_fas.stopped', text_fas.tStopRefresh)
thisExp.addData('FAS1.response', FAS1.getRating())
thisExp.addData('FAS1.rt', FAS1.getRT())
thisExp.addData('FAS1.started', FAS1.tStartRefresh)
thisExp.addData('FAS1.stopped', FAS1.tStopRefresh)
# the Routine "FAS" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Instr_3back_T"-------
continueRoutine = True
# update component parameters for each repeat
key_resp.keys = []
key_resp.rt = []
_key_resp_allKeys = []
# keep track of which components have finished
Instr_3back_TComponents = [text_3backT, key_resp]
for thisComponent in Instr_3back_TComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Instr_3back_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Instr_3back_T"-------
while continueRoutine:
    # get current time
    t = Instr_3back_TClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=Instr_3back_TClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_3backT* updates
    if text_3backT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_3backT.frameNStart = frameN  # exact frame index
        text_3backT.tStart = t  # local t and not account for scr refresh
        text_3backT.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_3backT, 'tStartRefresh')  # time at next scr refresh
        text_3backT.setAutoDraw(True)
    
    # *key_resp* updates
    waitOnFlip = False
    if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp.frameNStart = frameN  # exact frame index
        key_resp.tStart = t  # local t and not account for scr refresh
        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
        key_resp.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp.status == STARTED and not waitOnFlip:
        theseKeys = key_resp.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_allKeys.extend(theseKeys)
        if len(_key_resp_allKeys):
            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
            key_resp.rt = _key_resp_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in Instr_3back_TComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Instr_3back_T"-------
for thisComponent in Instr_3back_TComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_3backT.started', text_3backT.tStartRefresh)
thisExp.addData('text_3backT.stopped', text_3backT.tStopRefresh)
# check responses
if key_resp.keys in ['', [], None]:  # No response was made
    key_resp.keys = None
thisExp.addData('key_resp.keys',key_resp.keys)
if key_resp.keys != None:  # we had a response
    thisExp.addData('key_resp.rt', key_resp.rt)
thisExp.addData('key_resp.started', key_resp.tStartRefresh)
thisExp.addData('key_resp.stopped', key_resp.tStopRefresh)
thisExp.nextEntry()
# the Routine "Instr_3back_T" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
BlockTestNback3 = data.TrialHandler(nReps=1.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=data.importConditions('Files/Nback3BlockList.xlsx'),
    seed=None, name='BlockTestNback3')
thisExp.addLoop(BlockTestNback3)  # add the loop to the experiment
thisBlockTestNback3 = BlockTestNback3.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisBlockTestNback3.rgb)
if thisBlockTestNback3 != None:
    for paramName in thisBlockTestNback3:
        exec('{} = thisBlockTestNback3[paramName]'.format(paramName))

for thisBlockTestNback3 in BlockTestNback3:
    currentLoop = BlockTestNback3
    # abbreviate parameter names if possible (e.g. rgb = thisBlockTestNback3.rgb)
    if thisBlockTestNback3 != None:
        for paramName in thisBlockTestNback3:
            exec('{} = thisBlockTestNback3[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "InstructionBlock"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_Block1.keys = []
    key_resp_Block1.rt = []
    _key_resp_Block1_allKeys = []
    # keep track of which components have finished
    InstructionBlockComponents = [textInstrBlock1, key_resp_Block1]
    for thisComponent in InstructionBlockComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    InstructionBlockClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "InstructionBlock"-------
    while continueRoutine:
        # get current time
        t = InstructionBlockClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=InstructionBlockClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *textInstrBlock1* updates
        if textInstrBlock1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            textInstrBlock1.frameNStart = frameN  # exact frame index
            textInstrBlock1.tStart = t  # local t and not account for scr refresh
            textInstrBlock1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(textInstrBlock1, 'tStartRefresh')  # time at next scr refresh
            textInstrBlock1.setAutoDraw(True)
        
        # *key_resp_Block1* updates
        waitOnFlip = False
        if key_resp_Block1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_Block1.frameNStart = frameN  # exact frame index
            key_resp_Block1.tStart = t  # local t and not account for scr refresh
            key_resp_Block1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_Block1, 'tStartRefresh')  # time at next scr refresh
            key_resp_Block1.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_Block1.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_Block1.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_Block1.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_Block1.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_Block1_allKeys.extend(theseKeys)
            if len(_key_resp_Block1_allKeys):
                key_resp_Block1.keys = _key_resp_Block1_allKeys[-1].name  # just the last key pressed
                key_resp_Block1.rt = _key_resp_Block1_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in InstructionBlockComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "InstructionBlock"-------
    for thisComponent in InstructionBlockComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback3.addData('textInstrBlock1.started', textInstrBlock1.tStartRefresh)
    BlockTestNback3.addData('textInstrBlock1.stopped', textInstrBlock1.tStopRefresh)
    # check responses
    if key_resp_Block1.keys in ['', [], None]:  # No response was made
        key_resp_Block1.keys = None
    BlockTestNback3.addData('key_resp_Block1.keys',key_resp_Block1.keys)
    if key_resp_Block1.keys != None:  # we had a response
        BlockTestNback3.addData('key_resp_Block1.rt', key_resp_Block1.rt)
    BlockTestNback3.addData('key_resp_Block1.started', key_resp_Block1.tStartRefresh)
    BlockTestNback3.addData('key_resp_Block1.stopped', key_resp_Block1.tStopRefresh)
    # the Routine "InstructionBlock" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    Test3backLoop = data.TrialHandler(nReps=1.0, method='sequential', 
        extraInfo=expInfo, originPath=-1,
        trialList=data.importConditions(Block),
        seed=None, name='Test3backLoop')
    thisExp.addLoop(Test3backLoop)  # add the loop to the experiment
    thisTest3backLoop = Test3backLoop.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTest3backLoop.rgb)
    if thisTest3backLoop != None:
        for paramName in thisTest3backLoop:
            exec('{} = thisTest3backLoop[paramName]'.format(paramName))
    
    for thisTest3backLoop in Test3backLoop:
        currentLoop = Test3backLoop
        # abbreviate parameter names if possible (e.g. rgb = thisTest3backLoop.rgb)
        if thisTest3backLoop != None:
            for paramName in thisTest3backLoop:
                exec('{} = thisTest3backLoop[paramName]'.format(paramName))
        
        # ------Prepare to start Routine "Nback3_T"-------
        continueRoutine = True
        routineTimer.add(1.500000)
        # update component parameters for each repeat
        stim_test_3back.setText(letter)
        key_resp_3backT.keys = []
        key_resp_3backT.rt = []
        _key_resp_3backT_allKeys = []
        # keep track of which components have finished
        Nback3_TComponents = [stim_test_3back, key_resp_3backT]
        for thisComponent in Nback3_TComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        Nback3_TClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "Nback3_T"-------
        while continueRoutine and routineTimer.getTime() > 0:
            # get current time
            t = Nback3_TClock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=Nback3_TClock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *stim_test_3back* updates
            if stim_test_3back.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                stim_test_3back.frameNStart = frameN  # exact frame index
                stim_test_3back.tStart = t  # local t and not account for scr refresh
                stim_test_3back.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(stim_test_3back, 'tStartRefresh')  # time at next scr refresh
                stim_test_3back.setAutoDraw(True)
            if stim_test_3back.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > stim_test_3back.tStartRefresh + 0.5-frameTolerance:
                    # keep track of stop time/frame for later
                    stim_test_3back.tStop = t  # not accounting for scr refresh
                    stim_test_3back.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(stim_test_3back, 'tStopRefresh')  # time at next scr refresh
                    stim_test_3back.setAutoDraw(False)
            
            # *key_resp_3backT* updates
            waitOnFlip = False
            if key_resp_3backT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_3backT.frameNStart = frameN  # exact frame index
                key_resp_3backT.tStart = t  # local t and not account for scr refresh
                key_resp_3backT.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_3backT, 'tStartRefresh')  # time at next scr refresh
                key_resp_3backT.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_3backT.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_3backT.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_3backT.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > key_resp_3backT.tStartRefresh + 1.5-frameTolerance:
                    # keep track of stop time/frame for later
                    key_resp_3backT.tStop = t  # not accounting for scr refresh
                    key_resp_3backT.frameNStop = frameN  # exact frame index
                    win.timeOnFlip(key_resp_3backT, 'tStopRefresh')  # time at next scr refresh
                    key_resp_3backT.status = FINISHED
            if key_resp_3backT.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_3backT.getKeys(keyList=['a', 'l'], waitRelease=False)
                _key_resp_3backT_allKeys.extend(theseKeys)
                if len(_key_resp_3backT_allKeys):
                    key_resp_3backT.keys = _key_resp_3backT_allKeys[0].name  # just the first key pressed
                    key_resp_3backT.rt = _key_resp_3backT_allKeys[0].rt
                    # was this correct?
                    if (key_resp_3backT.keys == str(corrAns)) or (key_resp_3backT.keys == corrAns):
                        key_resp_3backT.corr = 1
                    else:
                        key_resp_3backT.corr = 0
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in Nback3_TComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "Nback3_T"-------
        for thisComponent in Nback3_TComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        Test3backLoop.addData('stim_test_3back.started', stim_test_3back.tStartRefresh)
        Test3backLoop.addData('stim_test_3back.stopped', stim_test_3back.tStopRefresh)
        # check responses
        if key_resp_3backT.keys in ['', [], None]:  # No response was made
            key_resp_3backT.keys = None
            # was no response the correct answer?!
            if str(corrAns).lower() == 'none':
               key_resp_3backT.corr = 1;  # correct non-response
            else:
               key_resp_3backT.corr = 0;  # failed to respond (incorrectly)
        # store data for Test3backLoop (TrialHandler)
        Test3backLoop.addData('key_resp_3backT.keys',key_resp_3backT.keys)
        Test3backLoop.addData('key_resp_3backT.corr', key_resp_3backT.corr)
        if key_resp_3backT.keys != None:  # we had a response
            Test3backLoop.addData('key_resp_3backT.rt', key_resp_3backT.rt)
        Test3backLoop.addData('key_resp_3backT.started', key_resp_3backT.tStartRefresh)
        Test3backLoop.addData('key_resp_3backT.stopped', key_resp_3backT.tStopRefresh)
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'Test3backLoop'
    
    # get names of stimulus parameters
    if Test3backLoop.trialList in ([], [None], None):
        params = []
    else:
        params = Test3backLoop.trialList[0].keys()
    # save data for this loop
    Test3backLoop.saveAsExcel(filename + '.xlsx', sheetName='Test3backLoop',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    Test3backLoop.saveAsText(filename + 'Test3backLoop.csv', delim=',',
        stimOut=params,
        dataOut=['n','all_mean','all_std', 'all_raw'])
    
    # ------Prepare to start Routine "BlockTxt"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blockfb.keys = []
    key_resp_blockfb.rt = []
    _key_resp_blockfb_allKeys = []
    # keep track of which components have finished
    BlockTxtComponents = [text_block, key_resp_blockfb]
    for thisComponent in BlockTxtComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    BlockTxtClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "BlockTxt"-------
    while continueRoutine:
        # get current time
        t = BlockTxtClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=BlockTxtClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_block* updates
        if text_block.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_block.frameNStart = frameN  # exact frame index
            text_block.tStart = t  # local t and not account for scr refresh
            text_block.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_block, 'tStartRefresh')  # time at next scr refresh
            text_block.setAutoDraw(True)
        
        # *key_resp_blockfb* updates
        waitOnFlip = False
        if key_resp_blockfb.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blockfb.frameNStart = frameN  # exact frame index
            key_resp_blockfb.tStart = t  # local t and not account for scr refresh
            key_resp_blockfb.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blockfb, 'tStartRefresh')  # time at next scr refresh
            key_resp_blockfb.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blockfb.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_blockfb.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_blockfb.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blockfb.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_blockfb_allKeys.extend(theseKeys)
            if len(_key_resp_blockfb_allKeys):
                key_resp_blockfb.keys = _key_resp_blockfb_allKeys[0].name  # just the first key pressed
                key_resp_blockfb.rt = _key_resp_blockfb_allKeys[0].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in BlockTxtComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "BlockTxt"-------
    for thisComponent in BlockTxtComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback3.addData('text_block.started', text_block.tStartRefresh)
    BlockTestNback3.addData('text_block.stopped', text_block.tStopRefresh)
    # check responses
    if key_resp_blockfb.keys in ['', [], None]:  # No response was made
        key_resp_blockfb.keys = None
    BlockTestNback3.addData('key_resp_blockfb.keys',key_resp_blockfb.keys)
    if key_resp_blockfb.keys != None:  # we had a response
        BlockTestNback3.addData('key_resp_blockfb.rt', key_resp_blockfb.rt)
    BlockTestNback3.addData('key_resp_blockfb.started', key_resp_blockfb.tStartRefresh)
    BlockTestNback3.addData('key_resp_blockfb.stopped', key_resp_blockfb.tStopRefresh)
    # the Routine "BlockTxt" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "FS"-------
    continueRoutine = True
    # update component parameters for each repeat
    FS1.reset()
    FS1.marker.size = (.03, .03)
    # keep track of which components have finished
    FSComponents = [text_fs, FS1]
    for thisComponent in FSComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    FSClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "FS"-------
    while continueRoutine:
        # get current time
        t = FSClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=FSClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_fs* updates
        if text_fs.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_fs.frameNStart = frameN  # exact frame index
            text_fs.tStart = t  # local t and not account for scr refresh
            text_fs.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_fs, 'tStartRefresh')  # time at next scr refresh
            text_fs.setAutoDraw(True)
        
        # *FS1* updates
        if FS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            FS1.frameNStart = frameN  # exact frame index
            FS1.tStart = t  # local t and not account for scr refresh
            FS1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(FS1, 'tStartRefresh')  # time at next scr refresh
            FS1.setAutoDraw(True)
        
        # Check FS1 for response to end routine
        if FS1.getRating() is not None and FS1.status == STARTED:
            continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in FSComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "FS"-------
    for thisComponent in FSComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback3.addData('text_fs.started', text_fs.tStartRefresh)
    BlockTestNback3.addData('text_fs.stopped', text_fs.tStopRefresh)
    BlockTestNback3.addData('FS1.response', FS1.getRating())
    BlockTestNback3.addData('FS1.rt', FS1.getRT())
    BlockTestNback3.addData('FS1.started', FS1.tStartRefresh)
    BlockTestNback3.addData('FS1.stopped', FS1.tStopRefresh)
    # the Routine "FS" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "FAS"-------
    continueRoutine = True
    # update component parameters for each repeat
    FAS1.reset()
    FAS1.marker.size = (.03, .03)
    # keep track of which components have finished
    FASComponents = [text_fas, FAS1]
    for thisComponent in FASComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    FASClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "FAS"-------
    while continueRoutine:
        # get current time
        t = FASClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=FASClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_fas* updates
        if text_fas.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_fas.frameNStart = frameN  # exact frame index
            text_fas.tStart = t  # local t and not account for scr refresh
            text_fas.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_fas, 'tStartRefresh')  # time at next scr refresh
            text_fas.setAutoDraw(True)
        
        # *FAS1* updates
        if FAS1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            FAS1.frameNStart = frameN  # exact frame index
            FAS1.tStart = t  # local t and not account for scr refresh
            FAS1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(FAS1, 'tStartRefresh')  # time at next scr refresh
            FAS1.setAutoDraw(True)
        
        # Check FAS1 for response to end routine
        if FAS1.getRating() is not None and FAS1.status == STARTED:
            continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in FASComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "FAS"-------
    for thisComponent in FASComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    BlockTestNback3.addData('text_fas.started', text_fas.tStartRefresh)
    BlockTestNback3.addData('text_fas.stopped', text_fas.tStopRefresh)
    BlockTestNback3.addData('FAS1.response', FAS1.getRating())
    BlockTestNback3.addData('FAS1.rt', FAS1.getRT())
    BlockTestNback3.addData('FAS1.started', FAS1.tStartRefresh)
    BlockTestNback3.addData('FAS1.stopped', FAS1.tStopRefresh)
    # the Routine "FAS" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    thisExp.nextEntry()
    
# completed 1.0 repeats of 'BlockTestNback3'

# get names of stimulus parameters
if BlockTestNback3.trialList in ([], [None], None):
    params = []
else:
    params = BlockTestNback3.trialList[0].keys()
# save data for this loop
BlockTestNback3.saveAsExcel(filename + '.xlsx', sheetName='BlockTestNback3',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])
BlockTestNback3.saveAsText(filename + 'BlockTestNback3.csv', delim=',',
    stimOut=params,
    dataOut=['n','all_mean','all_std', 'all_raw'])

# ------Prepare to start Routine "GoodBye"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_3.keys = []
key_resp_3.rt = []
_key_resp_3_allKeys = []
# keep track of which components have finished
GoodByeComponents = [Goodbye, key_resp_3]
for thisComponent in GoodByeComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
GoodByeClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "GoodBye"-------
while continueRoutine:
    # get current time
    t = GoodByeClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=GoodByeClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *Goodbye* updates
    if Goodbye.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        Goodbye.frameNStart = frameN  # exact frame index
        Goodbye.tStart = t  # local t and not account for scr refresh
        Goodbye.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(Goodbye, 'tStartRefresh')  # time at next scr refresh
        Goodbye.setAutoDraw(True)
    
    # *key_resp_3* updates
    waitOnFlip = False
    if key_resp_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_3.frameNStart = frameN  # exact frame index
        key_resp_3.tStart = t  # local t and not account for scr refresh
        key_resp_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_3, 'tStartRefresh')  # time at next scr refresh
        key_resp_3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_3.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_3.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_3_allKeys.extend(theseKeys)
        if len(_key_resp_3_allKeys):
            key_resp_3.keys = _key_resp_3_allKeys[-1].name  # just the last key pressed
            key_resp_3.rt = _key_resp_3_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in GoodByeComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "GoodBye"-------
for thisComponent in GoodByeComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('Goodbye.started', Goodbye.tStartRefresh)
thisExp.addData('Goodbye.stopped', Goodbye.tStopRefresh)
# check responses
if key_resp_3.keys in ['', [], None]:  # No response was made
    key_resp_3.keys = None
thisExp.addData('key_resp_3.keys',key_resp_3.keys)
if key_resp_3.keys != None:  # we had a response
    thisExp.addData('key_resp_3.rt', key_resp_3.rt)
thisExp.addData('key_resp_3.started', key_resp_3.tStartRefresh)
thisExp.addData('key_resp_3.stopped', key_resp_3.tStopRefresh)
thisExp.nextEntry()
# the Routine "GoodBye" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# Flip one final time so any remaining win.callOnFlip() 
# and win.timeOnFlip() tasks get executed before quitting
win.flip()

# these shouldn't be strictly necessary (should auto-save)
thisExp.saveAsWideText(filename+'.csv', delim='auto')
thisExp.saveAsPickle(filename)
logging.flush()
# make sure everything is closed down
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()
